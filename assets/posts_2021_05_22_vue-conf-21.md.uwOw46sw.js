import{_ as i,o as s,c as e,a as l}from"./chunks/framework.heUNgYAJ.js";const a="/assets/the-next-builder.Qz7ykyER.png",t="/assets/from-template-to-render-function.veONMmrq.png",n="/assets/composable-dependency-graph.U1I3-Gsz.png",p="/assets/reactive-like-excel.hU3NQOf1.png",h="/assets/kraken-intro.AeBoVfGU.png",r="/assets/kraken-diff-tech.h8MoeSWV.png",b=JSON.parse('{"title":"Vue Conf 21","description":"","frontmatter":{"date":"2021-5-22","updated":"2021-6-29","tags":["vue","vueconf","frontend"],"categories":["Computer Science","FrontEnd","Vue"]},"headers":[{"level":1,"title":"Vue Conf 21","slug":"vue-conf-21","link":"#vue-conf-21","children":[{"level":2,"title":"Vite","slug":"vite","link":"#vite","children":[{"level":3,"title":"为什么更快？","slug":"为什么更快","link":"#为什么更快","children":[]},{"level":3,"title":"SSR 目标","slug":"ssr-目标","link":"#ssr-目标","children":[]}]},{"level":2,"title":"编译优化思路","slug":"编译优化思路","link":"#编译优化思路","children":[]},{"level":2,"title":"Element3","slug":"element3","link":"#element3","children":[]},{"level":2,"title":"新一代构建工具","slug":"新一代构建工具","link":"#新一代构建工具","children":[{"level":3,"title":"Type First","slug":"type-first","link":"#type-first","children":[]},{"level":3,"title":"将类型检查放到编译外","slug":"将类型检查放到编译外","link":"#将类型检查放到编译外","children":[]},{"level":3,"title":"Be Explicit","slug":"be-explicit","link":"#be-explicit","children":[]},{"level":3,"title":"Module By Default","slug":"module-by-default","link":"#module-by-default","children":[]},{"level":3,"title":"构建工具的兼容难题","slug":"构建工具的兼容难题","link":"#构建工具的兼容难题","children":[]}]},{"level":2,"title":"减少 Node 依赖","slug":"减少-node-依赖","link":"#减少-node-依赖","children":[]},{"level":2,"title":"JSX","slug":"jsx","link":"#jsx","children":[{"level":3,"title":"什么是“真正的”JSX","slug":"什么是-真正的-jsx","link":"#什么是-真正的-jsx","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"Composition API","slug":"composition-api","link":"#composition-api","children":[{"level":3,"title":"为什么要组合式？","slug":"为什么要组合式","link":"#为什么要组合式","children":[]},{"level":3,"title":"什么是组合式？","slug":"什么是组合式","link":"#什么是组合式","children":[]},{"level":3,"title":"Reactive","slug":"reactive","link":"#reactive","children":[]},{"level":3,"title":"Best practices","slug":"best-practices","link":"#best-practices","children":[]}]},{"level":2,"title":"Vue 的 Flutter 实践","slug":"vue-的-flutter-实践","link":"#vue-的-flutter-实践","children":[]}]}],"relativePath":"posts/2021/05/22/vue-conf-21.md","filePath":"posts/2021/05/22/vue-conf-21.md"}'),o={name:"posts/2021/05/22/vue-conf-21.md"},d=l(`<h1 id="vue-conf-21" tabindex="-1">Vue Conf 21 <a class="header-anchor" href="#vue-conf-21" aria-label="Permalink to &quot;Vue Conf 21&quot;">​</a></h1><h2 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h2><h3 id="为什么更快" tabindex="-1">为什么更快？ <a class="header-anchor" href="#为什么更快" aria-label="Permalink to &quot;为什么更快？&quot;">​</a></h3><p>Vite 快速的核心原因时改变了原有的 Bundler-Based Dev Server，而采用 ESM-Based Dev Server 方案。Bundle-Base 的方案中，<strong>Full Bundler</strong> 决定了开发服务器的每次启动都十分低效，需要从入口文件解析整个依赖树并将其打包。而全新的 ESM-Based 开发服务器只需要做每个文件的 <strong>Transform</strong>，文件依赖解析则交由 ESM 完成，如此一来，开发服务器真的就只需要监听一个端口那么简单！</p><blockquote><p>其实可能还有依赖预构建，当然这也是为了更快</p></blockquote><h3 id="ssr-目标" tabindex="-1">SSR 目标 <a class="header-anchor" href="#ssr-目标" aria-label="Permalink to &quot;SSR 目标&quot;">​</a></h3><ul><li>Dev Bundless</li><li>Node 环境下加载 ESM <ul><li>兼容 Node 低版本</li><li>兼容生态环境</li></ul></li><li>支持 HMR+Plugin</li></ul><h2 id="编译优化思路" tabindex="-1">编译优化思路 <a class="header-anchor" href="#编译优化思路" aria-label="Permalink to &quot;编译优化思路&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* create  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* mount   */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* patch   */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* destory */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @vue/reactive</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* create  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* mount   */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* destory */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="element3" tabindex="-1">Element3 <a class="header-anchor" href="#element3" aria-label="Permalink to &quot;Element3&quot;">​</a></h2><ul><li>Headless/Styled</li><li>webGL -&gt; 材质</li></ul><h2 id="新一代构建工具" tabindex="-1">新一代构建工具 <a class="header-anchor" href="#新一代构建工具" aria-label="Permalink to &quot;新一代构建工具&quot;">​</a></h2><blockquote><p>别让构建流程成为技术包袱</p></blockquote><p><img src="`+a+'" alt="The Next Builder"></p><h3 id="type-first" tabindex="-1">Type First <a class="header-anchor" href="#type-first" aria-label="Permalink to &quot;Type First&quot;">​</a></h3><p>Type First, 类型优先 -&gt; TypeScript</p><ul><li>类型提示</li><li>智能补全</li><li>省下写文档的时间</li><li>方便重构</li></ul><h3 id="将类型检查放到编译外" tabindex="-1">将类型检查放到编译外 <a class="header-anchor" href="#将类型检查放到编译外" aria-label="Permalink to &quot;将类型检查放到编译外&quot;">​</a></h3><ul><li>esbuild: 单纯的 TypeScript 词法扩展并不会让编译变慢</li><li>把 tsc 作为 lint 的一部分</li></ul><h3 id="be-explicit" tabindex="-1">Be Explicit <a class="header-anchor" href="#be-explicit" aria-label="Permalink to &quot;Be Explicit&quot;">​</a></h3><ul><li><p>用 define* 的帮助函数：类型补全</p></li><li><p>不要省略文件名：类型</p></li></ul><h3 id="module-by-default" tabindex="-1">Module By Default <a class="header-anchor" href="#module-by-default" aria-label="Permalink to &quot;Module By Default&quot;">​</a></h3><ul><li><p>拥抱 ES Module</p></li><li><p>重新看待 Externals，在 ESM 时代，简单的 Externals 并不好用</p><ul><li>alias</li><li>import maps</li></ul></li><li><p><code>__filename</code> / <code>__dirname</code> / <code>require.resolve</code> =&gt; <code>import.meta.url</code></p></li><li><p><code>process.env</code> =&gt; <code>import.meta.env</code></p><ul><li>来自 Node.js，环境并不存在</li><li>浏览器端的 <code>process.env</code> 并不是环境，而是配置</li><li><code>NODE_ENV</code>有各种约定俗称的用法</li></ul></li><li><p>JSON modules =&gt; 标准只有 default import</p></li></ul><h3 id="构建工具的兼容难题" tabindex="-1">构建工具的兼容难题 <a class="header-anchor" href="#构建工具的兼容难题" aria-label="Permalink to &quot;构建工具的兼容难题&quot;">​</a></h3><p>浏览器兼容 &amp; 技术债务</p><ul><li>IE 11 =&gt; Retail</li><li>Dynamic Import</li><li>Node.js Polyfills &amp; Shims</li></ul><h2 id="减少-node-依赖" tabindex="-1">减少 Node 依赖 <a class="header-anchor" href="#减少-node-依赖" aria-label="Permalink to &quot;减少 Node 依赖&quot;">​</a></h2><p>抹平差距</p><ul><li>Define：简单的字符串替换</li><li>Mock / Sham：无实际功能的模拟，如 fs</li><li>Shim / Polyfill：模拟完整功能，如 path</li></ul><p>用 globalThis 代替 global/window</p><h2 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h2><p><img src="'+t+`" alt="From Template to Render Function"></p><p>利用 Babel 赋予的编译能力，实现模板与 JSX 跨语言联动，以用户的需求为抓手，摸索出一套适用于 Vue 的 JSX 方法论，打造 Vue 生态闭环，利用 TypeScript 的类型提示，为更习惯于 JSX 的开发者赋能。</p><h3 id="什么是-真正的-jsx" tabindex="-1">什么是“真正的”JSX <a class="header-anchor" href="#什么是-真正的-jsx" aria-label="Permalink to &quot;什么是“真正的”JSX&quot;">​</a></h3><p>JSX 最早由 Facebook 起草，用于 React，但不是 tc39 的规范，因此浏览器不会直接实现。JSX 需要由编译器和框架来&quot;赋能&quot;，以下列代码为例：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, world!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>经过编译后（通过 Babel, ts 等工具转换 AST）：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _createVNode } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_createVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;h1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li><p><strong>额外的运行时</strong>：JSX 无法判断 slot 或 children，只能在运行时判断</p></li><li><p><strong>信息不足</strong>：JSX 语法自由的代价就是难以实现静态分析，编译信息较少，Vue3 引入的<code>PatchFlags</code>无法完全做到，导致 JSX 编译后的 <code>Render Function</code> 性能差一些</p></li></ol><h2 id="composition-api" tabindex="-1">Composition API <a class="header-anchor" href="#composition-api" aria-label="Permalink to &quot;Composition API&quot;">​</a></h2><blockquote><p>PPT: <a href="https://talks.antfu.me/2021/vueconf-china" target="_blank" rel="noreferrer">https://talks.antfu.me/2021/vueconf-china</a></p></blockquote><h3 id="为什么要组合式" tabindex="-1">为什么要组合式？ <a class="header-anchor" href="#为什么要组合式" aria-label="Permalink to &quot;为什么要组合式？&quot;">​</a></h3><ul><li><p>对象式变量来源不明确</p></li><li><p>Type 补全复杂</p></li></ul><h3 id="什么是组合式" tabindex="-1">什么是组合式？ <a class="header-anchor" href="#什么是组合式" aria-label="Permalink to &quot;什么是组合式？&quot;">​</a></h3><ul><li><p>可复用逻辑的组合，其中每个函数都可以独立使用</p></li><li><p>专注点分离</p></li></ul><p><img src="`+n+'" alt="Composable Dependency Graph"></p><h3 id="reactive" tabindex="-1">Reactive <a class="header-anchor" href="#reactive" aria-label="Permalink to &quot;Reactive&quot;">​</a></h3><p>不同于 React，Vue 的 <code>Setup()</code> 只会在组件建立时执行一次，在此期间会建立起数据与逻辑之间的连结。</p><ul><li>建立输入 → 输出的连结</li><li>输出会根据输入的改变而改变（就像你的 Excel 一样 🎉）</li></ul><p><img src="'+p+`" alt="Reactive Like Excel"></p><h3 id="best-practices" tabindex="-1">Best practices <a class="header-anchor" href="#best-practices" aria-label="Permalink to &quot;Best practices&quot;">​</a></h3><ul><li><p>优先使用 <code>ref</code> 而不是 <code>reactive</code></p><ul><li><p>显示调用，类型检查</p></li><li><p>相比 Reactive 局限更少：<code>reactive </code>有类型，无法解构……</p></li></ul></li><li><p>Ref 自动解包</p><ul><li><p><code>watch</code> 直接接收 Ref ，回调中会自动解包</p></li><li><p>Ref 在模板中自动解包</p></li><li><p>使用 <code>reactive</code> 解包嵌套 <code>ref</code>，用来代替 <code>toRef</code></p></li></ul></li><li><p><code>unref</code> API</p><ul><li><p><code>unref(a) =&gt; isRef(a) ? a.value : a</code></p></li><li><p>接收 Ref 作为函数参数 <code>(a, b) =&gt; unref(a) + unref(b)</code></p></li></ul></li><li><p><code>type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T </code></p></li><li><p>重复使用 ref，<code>ref </code>会自动解包的！</p><ul><li><code>newRef = isRef(foo) ? foo : ref(foo)</code>和<code>newRef = ref(foo)</code> 一样的</li></ul></li><li><p>副作用自动清除</p><ul><li><p>组件内的 <code>watch</code> 和 <code>computed</code> 会在销毁时自动清除</p></li><li><p>Vue 3.2: <code>effectScope</code></p></li></ul></li><li><p>类型安全的 <code>Provide</code>/<code>Inject</code>：<code>InjectionKey&lt;T&gt;</code></p></li><li><p>状态共享</p><ul><li><p>直接用 Composition API 把状态抽离</p></li><li><p>使用 <code>provide</code>/<code>inject</code> 来共享应用层面的状态</p></li></ul></li><li><p>小技巧：<code>useVModel</code></p></li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useVModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> emit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getCurrentInstance.emit</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> props[name]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`update\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, v)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>Vue Demi: 一套代码，同时适用 Vue 2 和 Vue 3</li></ul><h2 id="vue-的-flutter-实践" tabindex="-1">Vue 的 Flutter 实践 <a class="header-anchor" href="#vue-的-flutter-实践" aria-label="Permalink to &quot;Vue 的 Flutter 实践&quot;">​</a></h2><ul><li>移动端技术栈演变：WebView -&gt; Hybrid -&gt; RN -&gt; Flutter</li></ul><p><img src="`+h+'" alt="Kraken Intro"></p><p><img src="'+r+'" alt="Kraken Diff Tech"></p>',59),c=[d];function k(u,E,g,y,m,f){return s(),e("div",null,c)}const F=i(o,[["render",k]]);export{b as __pageData,F as default};
