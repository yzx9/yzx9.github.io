import{_ as t,o as l,c as e,a}from"./chunks/framework.heUNgYAJ.js";const _=JSON.parse('{"title":"LL(1) 文法的实现","description":"","frontmatter":{"date":"2021-3-10","updated":"2021-3-10","categories":["Computer Science","Compiler"],"tags":["Grammar"]},"headers":[{"level":1,"title":"LL(1) 文法的实现","slug":"ll-1-文法的实现","link":"#ll-1-文法的实现","children":[{"level":2,"title":"递归下降预测分析程序","slug":"递归下降预测分析程序","link":"#递归下降预测分析程序","children":[]},{"level":2,"title":"表驱动的预测分析程序","slug":"表驱动的预测分析程序","link":"#表驱动的预测分析程序","children":[{"level":3,"title":"下推自动机","slug":"下推自动机","link":"#下推自动机","children":[]}]},{"level":2,"title":"错误处理","slug":"错误处理","link":"#错误处理","children":[{"level":3,"title":"错误检测","slug":"错误检测","link":"#错误检测","children":[]},{"level":3,"title":"错误恢复","slug":"错误恢复","link":"#错误恢复","children":[{"level":4,"title":"恐慌模式","slug":"恐慌模式","link":"#恐慌模式","children":[]}]}]},{"level":2,"title":"实现步骤","slug":"实现步骤","link":"#实现步骤","children":[]}]}],"relativePath":"posts/2021/03/10/implement-of-ll1-grammar.md","filePath":"posts/2021/03/10/implement-of-ll1-grammar.md"}'),i={name:"posts/2021/03/10/implement-of-ll1-grammar.md"},r=a('<h1 id="ll-1-文法的实现" tabindex="-1">LL(1) 文法的实现 <a class="header-anchor" href="#ll-1-文法的实现" aria-label="Permalink to &quot;LL(1) 文法的实现&quot;">​</a></h1><p>文法实现可以分为递归和非递归（表驱动）的实现方法，二者性能表现如下：</p><table><thead><tr><th></th><th>递归的预测分析法</th><th>表驱动的预测分析法</th></tr></thead><tbody><tr><td>程序规模</td><td>程序规模较大</td><td>程序规模较小，需加载分析表（表较小）</td></tr><tr><td>直观性</td><td>较好</td><td>较差</td></tr><tr><td>效率</td><td>较低</td><td>分析程序正比于代码长度</td></tr><tr><td>自动生成</td><td>较难</td><td>较易</td></tr></tbody></table><h2 id="递归下降预测分析程序" tabindex="-1">递归下降预测分析程序 <a class="header-anchor" href="#递归下降预测分析程序" aria-label="Permalink to &quot;递归下降预测分析程序&quot;">​</a></h2><h2 id="表驱动的预测分析程序" tabindex="-1">表驱动的预测分析程序 <a class="header-anchor" href="#表驱动的预测分析程序" aria-label="Permalink to &quot;表驱动的预测分析程序&quot;">​</a></h2><p>输入缓冲区和分析栈</p><h3 id="下推自动机" tabindex="-1">下推自动机 <a class="header-anchor" href="#下推自动机" aria-label="Permalink to &quot;下推自动机&quot;">​</a></h3><h2 id="错误处理" tabindex="-1">错误处理 <a class="header-anchor" href="#错误处理" aria-label="Permalink to &quot;错误处理&quot;">​</a></h2><h3 id="错误检测" tabindex="-1">错误检测 <a class="header-anchor" href="#错误检测" aria-label="Permalink to &quot;错误检测&quot;">​</a></h3><p>两种情况下我们可以检测到错误：</p><ul><li>栈顶的<strong>终结符</strong>和当前输入符号不匹配</li><li>栈顶<strong>非终结符</strong>和当前输入符号在预测分析表对应项中的信息为空</li></ul><h3 id="错误恢复" tabindex="-1">错误恢复 <a class="header-anchor" href="#错误恢复" aria-label="Permalink to &quot;错误恢复&quot;">​</a></h3><h4 id="恐慌模式" tabindex="-1">恐慌模式 <a class="header-anchor" href="#恐慌模式" aria-label="Permalink to &quot;恐慌模式&quot;">​</a></h4><p>忽略输入中的一些符号，直到遇到同步此法单元（synchronizing token）集合中的某个词法单元。</p><h2 id="实现步骤" tabindex="-1">实现步骤 <a class="header-anchor" href="#实现步骤" aria-label="Permalink to &quot;实现步骤&quot;">​</a></h2><ol><li>构造文法</li><li>改造文法：消除二义性、消除左递归、消除回溯</li><li>求每个变量的FIRST集和FOLLOW集，从而求出每个候选式的SELECT集</li><li>检查文法是否为LL(1)文法。若是，则构造预测分析表</li><li>实现算法 <ul><li>对于递归的预测分析，根据预测分析表为每一个运算符编写一个过程</li><li>对于表驱动预测分析，实现表驱动的分析算法</li></ul></li></ol>',16),d=[r];function o(n,h,s,c,m,u){return l(),e("div",null,d)}const b=t(i,[["render",o]]);export{_ as __pageData,b as default};
