import{_ as t,o as a,c as e,a as n}from"./chunks/framework.heUNgYAJ.js";const i="/assets/2-bit-saturating-counter.urZXGBin.jpg",k=JSON.parse('{"title":"取指周期","description":"","frontmatter":{"title":"取指周期","date":"2021-01-01T00:00:00.000Z","updated":"2021-01-01T00:00:00.000Z","categories":["Computer Science","Computer Organization"],"tags":["Computer Organization"]},"headers":[{"level":1,"title":"取指（Instruction Fetch）","slug":"取指-instruction-fetch","link":"#取指-instruction-fetch","children":[{"level":2,"title":"如何加快取值","slug":"如何加快取值","link":"#如何加快取值","children":[{"level":3,"title":"ITCM（Instruction Tightly Coupled Memory）","slug":"itcm-instruction-tightly-coupled-memory","link":"#itcm-instruction-tightly-coupled-memory","children":[]},{"level":3,"title":"I-Cache（Instruction Cache）","slug":"i-cache-instruction-cache","link":"#i-cache-instruction-cache","children":[]}]},{"level":2,"title":"如何处理非对齐指令","slug":"如何处理非对齐指令","link":"#如何处理非对齐指令","children":[{"level":3,"title":"剩余缓存（普通指令非对齐）","slug":"剩余缓存-普通指令非对齐","link":"#剩余缓存-普通指令非对齐","children":[]},{"level":3,"title":"多体化的SRAM存储（分支跳转指令）","slug":"多体化的sram存储-分支跳转指令","link":"#多体化的sram存储-分支跳转指令","children":[]}]},{"level":2,"title":"如何处理分支指令","slug":"如何处理分支指令","link":"#如何处理分支指令","children":[{"level":3,"title":"无条件跳转指令（Unconditional Jump/Branch）","slug":"无条件跳转指令-unconditional-jump-branch","link":"#无条件跳转指令-unconditional-jump-branch","children":[]},{"level":3,"title":"有条件跳转指令（Conditional Jump/Branch）","slug":"有条件跳转指令-conditional-jump-branch","link":"#有条件跳转指令-conditional-jump-branch","children":[{"level":4,"title":"静态分支预测","slug":"静态分支预测","link":"#静态分支预测","children":[{"level":5,"title":"总预测不跳转（Always Not Taken）","slug":"总预测不跳转-always-not-taken","link":"#总预测不跳转-always-not-taken","children":[]},{"level":5,"title":"BTFN预测（Back Taken, Forward Not Taken）","slug":"btfn预测-back-taken-forward-not-taken","link":"#btfn预测-back-taken-forward-not-taken","children":[]}]},{"level":4,"title":"动态分支预测","slug":"动态分支预测","link":"#动态分支预测","children":[{"level":5,"title":"一比特饱和计数器（1-bit Saturating Counter）","slug":"一比特饱和计数器-1-bit-saturating-counter","link":"#一比特饱和计数器-1-bit-saturating-counter","children":[]},{"level":5,"title":"二比特饱和计数器（2-bit Saturating Counter）","slug":"二比特饱和计数器-2-bit-saturating-counter","link":"#二比特饱和计数器-2-bit-saturating-counter","children":[]}]}]}]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}]}],"relativePath":"posts/2021/01/01/instruction-fetch.md","filePath":"posts/2021/01/01/instruction-fetch.md"}'),r={name:"posts/2021/01/01/instruction-fetch.md"},l=n('<h1 id="取指-instruction-fetch" tabindex="-1">取指（Instruction Fetch） <a class="header-anchor" href="#取指-instruction-fetch" aria-label="Permalink to &quot;取指（Instruction Fetch）&quot;">​</a></h1><p>取指是指处理器核将指令从存储器中读取出来的过程（按照其指令PC值所对应的存储器地址</p><p>取指的终极目的是以最<strong>快</strong>的速度且<strong>连续不断</strong>地从存储器中取出指令供处理器核执行，为了达到这两个目标，我们需要达到如下性能：</p><ul><li>对于非分支跳转指令，能够连续不断的按顺序将其从存储器中快速读取出来，即便是地址不对其的指令，也最好能够连续不断的从每个周期读出一条指令</li><li>对于分支跳转指令，能够快速判断其是否需要跳转，并快速取出指令</li></ul><h2 id="如何加快取值" tabindex="-1">如何加快取值 <a class="header-anchor" href="#如何加快取值" aria-label="Permalink to &quot;如何加快取值&quot;">​</a></h2><h3 id="itcm-instruction-tightly-coupled-memory" tabindex="-1">ITCM（Instruction Tightly Coupled Memory） <a class="header-anchor" href="#itcm-instruction-tightly-coupled-memory" aria-label="Permalink to &quot;ITCM（Instruction Tightly Coupled Memory）&quot;">​</a></h3><p>ITCM（指令紧耦合寄存器）是指配置一段较小容量的（一般几十KB）的存储器（通常使用SRAM），用于存储指令，且在物理上离处理器核近而专属于处理器核。大多数极低功耗的处理器应用场景都是实时性较高的场景，因此倾向于使用延迟确定的ITCM。</p><p><strong>优点</strong>：实现简单，容易理解，能够保证实时性</p><p><strong>缺点</strong>：使用地址区间寻址（无法像Cache一样映射无限大的存储空间），容量小（保证访问能在一个时钟周期内完成）</p><h3 id="i-cache-instruction-cache" tabindex="-1">I-Cache（Instruction Cache） <a class="header-anchor" href="#i-cache-instruction-cache" aria-label="Permalink to &quot;I-Cache（Instruction Cache）&quot;">​</a></h3><p>指令缓存，是指利用软件程序的时间局部性和空间局部性，将存储器映射到Cache中，可以将平均访问时间降到最低。</p><p><strong>优点</strong>：平均访问时间短</p><p><strong>缺点</strong>：实时性差（访问时间存在不确定性）</p><h2 id="如何处理非对齐指令" tabindex="-1">如何处理非对齐指令 <a class="header-anchor" href="#如何处理非对齐指令" aria-label="Permalink to &quot;如何处理非对齐指令&quot;">​</a></h2><p>本段假设只存在16位和32位指令，且每次访存（ITCM）取出32位。</p><h3 id="剩余缓存-普通指令非对齐" tabindex="-1">剩余缓存（普通指令非对齐） <a class="header-anchor" href="#剩余缓存-普通指令非对齐" aria-label="Permalink to &quot;剩余缓存（普通指令非对齐）&quot;">​</a></h3><p>对于按顺序取指的32位普通指令，可以使用剩余缓存（Leftover Buffer）保存上次没有用完的比特位，供下次使用。造成指令非对齐的情况共有两种：</p><ul><li>只需要使用此次取出的32位中低16位和上一次取出的高16位组成一条32位指令</li><li>这条指令本身就是16位的，因此只需要取出低16位</li></ul><p>对于此次未使用的高16位，可以暂存于剩余缓存中，待下个周期取出32位指令字后，就可以马上拼出32位指令字。</p><h3 id="多体化的sram存储-分支跳转指令" tabindex="-1">多体化的SRAM存储（分支跳转指令） <a class="header-anchor" href="#多体化的sram存储-分支跳转指令" aria-label="Permalink to &quot;多体化的SRAM存储（分支跳转指令）&quot;">​</a></h3><p>对于分支跳转指令而言，如果跳转地址与32位边界不对齐，且需要取出一个32位指令字，剩余缓存自然是没用的。对此，通常的实现方式是使用多体（Bank）化的SRAM进行指令存储。</p><p>以常用的奇偶交错方式为例，使用两块32位宽的SRAM交错存储，两个连续的32位指令字会被分别存储在不同的SRAM中，对于不对齐的32位指令字，一个周期内可以同时访问两块SRAM取出两个32位指令字，然后将其拼接成真正需要的32位指令。</p><h2 id="如何处理分支指令" tabindex="-1">如何处理分支指令 <a class="header-anchor" href="#如何处理分支指令" aria-label="Permalink to &quot;如何处理分支指令&quot;">​</a></h2><h3 id="无条件跳转指令-unconditional-jump-branch" tabindex="-1">无条件跳转指令（Unconditional Jump/Branch） <a class="header-anchor" href="#无条件跳转指令-unconditional-jump-branch" aria-label="Permalink to &quot;无条件跳转指令（Unconditional Jump/Branch）&quot;">​</a></h3><p>其中又分为无条件跳转/分支（Unconditional Direct Jump/Branch）和无条件间接跳转分支（Unconditional Indirect Jump/Branch），此处的“直接“和”间接“指的是跳转地址从指令字的立即数取出或从寄存器取出。</p><p>无条件跳转指令可以在取指并移码后直接跳转，不会引起流水线空泡（Bubble）。</p><h3 id="有条件跳转指令-conditional-jump-branch" tabindex="-1">有条件跳转指令（Conditional Jump/Branch） <a class="header-anchor" href="#有条件跳转指令-conditional-jump-branch" aria-label="Permalink to &quot;有条件跳转指令（Conditional Jump/Branch）&quot;">​</a></h3><p>有条件跳转指令同样分为有条件直接跳转/分支（Conditional Direct Jump/Branch）和有条件间接跳转分支（Conditional Indirect Jump/Branch）。</p><p>有条件跳转指令的跳转地址需要等到执行阶段结束才能够得到真实的跳转地址，会导致流水线停顿，通常有两种方式解决该问题：</p><ol><li>流水线停顿，控制单元暂停取指或加入NOP（无动作）指令，此动作会一直持续到可能造成上述冲突的指令已执行完成为止</li><li>加入分支预测（branch prediction），预测分支指令跳转地址，当预测与真实跳转地址不符时，则冲刷流水线（Flush Pipeline）</li></ol><p>不难发现，高效的分支预测可以显著提高流水线效率，预测单元主要完成两个工作：</p><ol><li>对分支指令跳转方向预测</li><li>计算得出跳转地址</li></ol><p>目前，分支预测已经可以达到90%以上的准确率。</p><h4 id="静态分支预测" tabindex="-1">静态分支预测 <a class="header-anchor" href="#静态分支预测" aria-label="Permalink to &quot;静态分支预测&quot;">​</a></h4><p>静态预测是最简单的分支预测，仅依赖于当前指令给出信息做出预测，一般而言，静态分支预测可以由编译器完成。</p><h5 id="总预测不跳转-always-not-taken" tabindex="-1">总预测不跳转（Always Not Taken） <a class="header-anchor" href="#总预测不跳转-always-not-taken" aria-label="Permalink to &quot;总预测不跳转（Always Not Taken）&quot;">​</a></h5><p>对于分支指令总是预测为不会跳转。为了弥补冲刷流水线造成的性能损失，很多早期的RICS架构均使用了”分支延迟槽（Delay Slot）“的技术，即在分支指令后插入一条或若干条指令不受分支跳转的影响，不论分支是否跳转，后面的几条指令都一定会被执行。分支指令后几条的指令所在位置，就被称为分支延迟槽。由于分支延迟槽中的几条指令用于不会被执行而不会被退休（retired），因此不会受到冲刷流水线的影响。</p><h5 id="btfn预测-back-taken-forward-not-taken" tabindex="-1">BTFN预测（Back Taken, Forward Not Taken） <a class="header-anchor" href="#btfn预测-back-taken-forward-not-taken" aria-label="Permalink to &quot;BTFN预测（Back Taken, Forward Not Taken）&quot;">​</a></h5><p>BTFN预测，即对于向后跳转的指令预测为跳转，对于向前跳转的指令预测为不跳。BTFN方法的依据是向后跳转的情形要多余向前跳转的情形，譬如常见的for循环生成的指令中往往使用向后跳转的分支指令。</p><h4 id="动态分支预测" tabindex="-1">动态分支预测 <a class="header-anchor" href="#动态分支预测" aria-label="Permalink to &quot;动态分支预测&quot;">​</a></h4><p>动态预测是指依赖已经执行过的历史信息和分支指令本身的信息综合进行”方向“预测。</p><h5 id="一比特饱和计数器-1-bit-saturating-counter" tabindex="-1">一比特饱和计数器（1-bit Saturating Counter） <a class="header-anchor" href="#一比特饱和计数器-1-bit-saturating-counter" aria-label="Permalink to &quot;一比特饱和计数器（1-bit Saturating Counter）&quot;">​</a></h5><p>该策略采用一比特记录当前状态，共有两个状态，分别表示预测跳转/不跳转，即该策略使用上次跳转结果作为本次跳转预测。</p><h5 id="二比特饱和计数器-2-bit-saturating-counter" tabindex="-1">二比特饱和计数器（2-bit Saturating Counter） <a class="header-anchor" href="#二比特饱和计数器-2-bit-saturating-counter" aria-label="Permalink to &quot;二比特饱和计数器（2-bit Saturating Counter）&quot;">​</a></h5><p>该策略采用二比特记录当前状态，共有四个状态，如下图所示：</p><p><img src="'+i+'" alt="2-bit Saturating Counter State Transition Diagram"></p><p>图左边两个状态为不采纳(not token)，右边两个为采纳(token)。当不发生跳转时，状态向左移动一次；当不发生跳转时，状态向右移动一次。由红色到绿色需要连续两次分支选择。据评测，二比特饱和计数器的正确率可达到93.5%，预测期一般在分支指令解码前起作用。</p><p>二比特饱和计数器在理论上达到了较高正确率，但是实际应用中，会受到其他因素干扰，例如不同分支指令的跳转概率不同，对此可以对每个指令分设不同的计数器。在这样一系列的考量下，我们发展出了两级自适应预测器，局部/全局分支预测器，融合分支预测器，Agree预测器，神经分支预测器等。</p><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h2><ul><li>《手把手教你设计CPU——RISC处理器篇》胡振波</li></ul>',50),o=[l];function c(h,u,s,d,p,b){return a(),e("div",null,o)}const g=t(r,[["render",c]]);export{k as __pageData,g as default};
