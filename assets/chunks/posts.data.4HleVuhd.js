const n=JSON.parse(`{"posts":{"/posts/2019/03/16/json-web-token.html":{"url":"/posts/2019/03/16/json-web-token.html","title":"Json Web Token","excerpt":"主要用途 身份认证, 签名数据, 可以防止被篡改, 但不能储存未加密数据\\n\\n同类技术 session 复制, session 持久化\\n\\nAuth0\\n\\nRFC 7519\\n\\n结构\\n\\nHeader.Playload.Signature\\n\\nHeader\\n\\n{\\n  \\"alg\\": \\"HS256\\",\\n  \\"typ\\": \\"JWT\\"\\n}\\n\\nPayload\\n\\nhttps://www.iana.org/assignments/jwt/jwt.xhtml\\n\\nSignature\\n\\nHMACSHA256(\\n  base64UrlEncode(header) + \\".\\" + base64UrlEncode(payload),\\n  your - 256 - bit - secret\\n)\\n\\nHTTP Header\\n\\nAuthorization: Bearer\\n\\n优点\\n\\n自包含: 降低数据库请求次数\\n不用担心 CORS\\n服务器无状态，易横向扩展\\n\\n缺点\\n\\n包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限\\n\\n  有效期不宜太长\\n  重要操作时应验证身份\\n  HTTPS\\n\\n服务器无状态，无法撤销令牌\\n签名数据可...","tags":[{"slug":"authorization","raw":"Authorization"},{"slug":"jwt","raw":"JWT"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[]}],"createdAt":"2019-03-16T11:37:11.000Z"},"/posts/2019/03/16/oauth2.html":{"url":"/posts/2019/03/16/oauth2.html","title":"OAuth 2","excerpt":"RFC6749\\n\\n名词定义\\n\\nThird-party application\\n\\n第三方应用程序，本文中又称\\"客户端\\"(client)\\n\\nHTTP service\\n\\nHTTP服务提供商，本文中简称\\"服务提供商\\"，即上一节例子中的Google。\\n\\nResource Owner\\n\\n资源所有者，本文中又称\\"用户\\"（user）\\n\\nUser Agent\\n\\n用户代理，本文中就是指浏览器。\\n\\nAuthorization server\\n\\n认证服务器，即服务提供商专门用来处理认证的服务器\\n\\nResource server\\n\\n资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。\\n\\nAuthorization Code Mode\\n\\n1. 用户访问客户端 (Client)\\n\\n2. 客户端将用户导向至认证服务器(Authorization Server)\\n\\n信息通过 url 明文传输, 对用户可见\\n\\nresponse_type : code\\nclient_id\\nredirect_uri\\nscope(可选)\\nstate(可选)\\n  用于保持请求和响应状态\\n ...","tags":[{"slug":"authorization","raw":"Authorization"},{"slug":"oauth2","raw":"OAuth2"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[]}],"createdAt":"2019-03-16T10:37:11.000Z"},"/posts/2019/07/28/high-performance-web-sites-essential.html":{"url":"/posts/2019/07/28/high-performance-web-sites-essential.html","title":"高性能网站建设指南","excerpt":"JavaScript\\n\\n精简\\n\\n精简 (删除空格, 删除换行等)\\n混淆 (改变变量名)\\n  技术不成熟\\n  Class 属性不可混淆\\n  函数内局部变量可混淆\\nTree-Sharking\\n  Webpack 2 支持\\n  rollup 原生支持\\n\\n阻塞\\n\\n放在底部** 可改变 DOM 树结构\\ndefer** H4, load 后加载\\nasync** H5, 下载完加载\\n  \\\\ 后紧跟 \\\\ 可能阻塞脚本下载\\n多个 script 标签可并行下载, 浏览器会模拟线性加载\\n\\n去重\\n定义全局变量\\n使 Ajax 可缓存\\n\\n外联\\n\\n可缓存\\n加载必须脚本, 动态加载剩余脚本\\n\\nCSS\\n\\n放在头部\\n白屏\\nFOUC（无样式内容的闪烁）\\n流式渲染\\n\\n避免表达式\\n\\nCSS还有表达式？？？\\n\\n精简\\n\\n0px -> 0\\n#660066 -> #606\\n合并相同类，去除无用类\\n  optimize-css-assets-webpack-plugin\\n\\n外联\\n\\n内联更快, 但外联可重用/缓存,且可以预下载\\n\\nHTTP\\n\\nExpires 头\\n\\n设长期，通过全量更新弃用\\n\\n配置 ETag\\n\\n或者删除\\n\\ngzip\\nIE 5...","tags":[{"slug":"performance","raw":"Performance"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/front-end","raw":"Front End","children":[]}]}],"createdAt":"2019-07-28T00:00:00.000Z"},"/posts/2019/10/24/graph.html":{"url":"/posts/2019/10/24/graph.html","title":"图","excerpt":"[[toc]]\\n\\n基本术语\\n\\n完全图 (每个顶点之间都有边/弧连接)\\n稀疏图/稠密图: $n log_n$\\n度 (v 相关联边数), 出度/入度\\n权 -> 网\\n路径/回路(环), 简单路径: 无重复顶点\\n连通图\\n\\n存储结构\\n\\n邻接矩阵表示法\\n\\n那当然是一个矩阵咯\\n优点: 方便啊\\n缺点: 对稀疏图来说, 浪费空间\\n\\n邻接表表示法 (图的数组表示法)\\n\\n数组储存顶点, 链表储存弧\\n\\n十字链表\\n\\n邻接多重表\\n\\n遍历\\n\\nvisited[]\\n\\n深度优先搜索 (Deep First Search)\\n\\npre[]; // => 记录前驱结点, 同时充当 visited\\nStack stack;\\n\\n广度优先搜索 (Breadth First Search)\\n\\npre[];\\nQuery query;\\n\\n最小生成树\\n\\n生成树:\\n\\nDFS -> 深度优先生成树\\nBFS -> 广度优先生成树\\n\\n最小生成树:\\n\\n一副连通加权无向图中一棵权值最小的生成树\\n\\n普里姆算法 (prim)\\n\\n任选起点\\n选择权值最小且连接已选结点与未选结点的边加入树\\n重复步骤 2\\n\\n| 存储结构 | 复杂度         |\\n| ---...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/graph","raw":"Graph","children":[]}]}]}],"createdAt":"2019-10-24T19:30:32.000Z"},"/posts/2019/10/24/hash.html":{"url":"/posts/2019/10/24/hash.html","title":"哈希","excerpt":"哈希函数\\n\\n原则:\\n\\n便于计算\\n地址分布均匀\\n\\n方法:\\n\\n数字分析法\\n平方取中法\\n分段叠加法\\n除留余数法\\n伪随机数法\\n\\n解决冲突\\n\\n开放定址法\\n\\n线性探测再散列: $d_i=1, 2, 3..., m-1$\\n二次探测再散列: $d_i=1^2, -1^2, 2^2, -2^2, 3^3, -3^3 ...$\\n伪随机探测再散列: $d_i=Pseudorandom\\\\ Sequence$\\n\\n再哈希\\n\\n构造多个哈希函数\\n\\n链地址法\\n\\n数组 + 链表\\n\\n公共溢出区\\n\\n基本表 + 溢出区\\n\\n性能分析\\n\\n装填因子:\\n\\n$$\\\\alpha = \\\\frac{number}{length}$$\\n\\n线性探测再散列\\n\\n$$\\n\\\\begin{aligned}\\nASL_{succ}\\\\approx\\\\frac{1}{2}(1+\\\\frac{1}{1-\\\\alpha})       \\\\\\\\\\nASL_{unsucc}\\\\approx\\\\frac{1}{2}(1+\\\\frac{1}{(1-\\\\alpha)^2}) \\\\\\\\\\n\\\\end{aligned}\\n$$\\n\\n伪随机探测再散列, 二次探测再散列, 再哈希法\\n\\n$$\\n\\\\begin{aligned...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/hash","raw":"Hash","children":[]}]}]}],"createdAt":"2019-10-24T19:30:32.000Z"},"/posts/2019/10/24/linear-list.html":{"url":"/posts/2019/10/24/linear-list.html","title":"线性表","excerpt":"定义: 在数据元素的非空有限集合中, 除第一个元素无直接前驱, 最后一个元素无直接后继节点外, 每个元素都有唯一的直接前驱和直接后继节点.\\n\\nADT\\n\\ninitList(L)\\ngetLength(L)\\nget(L, i)\\ninsert(L, i , e)\\ndel(L, i, e)\\nlocate(L, e)\\ndestroy(L)\\nclear(L)\\nisEmpty(L)\\n\\n顺序储存(数组)\\n\\n可索引\\n插入, 删除慢\\n长度受限\\n\\n链式储存\\n\\n插入, 删除快\\n无法索引\\n查询慢\\n\\n循环链表\\n\\n将最后一个指针指向表头节点\\n从每个节点都可以访问整个列表\\n查找前驱节点复杂度为 O(n)\\n\\n双向链表\\n\\n每个节点都保存指向前驱节点和后继节点的指针\\n查找前驱节点复杂度为 O(1)\\n\\n静态链表\\n\\n适用于没有指针/引用的语言\\n用大数组模拟内存分配, 记录下一个节点的 index\\n\\n查找\\n\\n顺序查找法\\n\\nData data[SIZE + 1]\\ndata[0] 为监视哨, 存放查找元素关键字\\n\\n二分法\\n\\n   顺序结构存储\\n   按大小有序排列\\n\\n分块查找法\\n\\n   块内无序\\n   块与块之间有序\\n\\nQueue\\n\\n...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/linear-list","raw":"Linear List","children":[]}]}]}],"createdAt":"2019-10-24T19:30:32.000Z"},"/posts/2019/10/24/sort.html":{"url":"/posts/2019/10/24/sort.html","title":"排序","excerpt":"插入排序\\n\\n将第 i 个记录插入前面 i-1 个已排序记录\\n\\n直接插入法\\n\\n监视哨:\\n\\n备份待插入数据\\n防止越界\\n\\n折半插入法\\n\\n改善比较效率, 但未改变元素插入效率\\n\\n希尔排序\\n\\n选取记录距离为$d_i(i=1)$, 将待排序序列中将间隔为$d_1$的记录分成一组, 组内排序\\ni++, 将待排序序列中将间隔为$d_i$的记录分成一组. 组内排序\\n重复步骤 2, 直到$d_i=1$\\n\\n比较\\n\\n| 算法     | 改进思路                   | 时间复杂度                       | 最好情况   | 最坏情况 | 空间复杂度 |\\n| -------- | -------------------------- | -------------------------------- | ---------- | -------- | ---------- |\\n| 直接插入 | 最好情况: n 较小, 基本有序 | $O(n^2)$                         | $O(n)$     | $O(n^2)$ | $O(1)$     ...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/sort","raw":"Sort","children":[]}]}]}],"createdAt":"2019-10-24T19:30:32.000Z"},"/posts/2019/10/24/string.html":{"url":"/posts/2019/10/24/string.html","title":"串","excerpt":"assign(chars)\\ninsert(S, pos, T) // 插入串\\ndel(S, pos, len)\\ncopy(T)\\ncompare(S, T)\\ngetLength(S)\\nclear(S)\\ncat(S, T) // 连接\\nsubString(S, pos, len)\\nsubIndex(S, T, pos) // 若 T 为 S 子串, 返回 T 在 S[pos] 后第一次出现的索引\\ndestory(S)\\n\\n实现\\n\\n定长串\\n\\ntypedef struct {\\n  char ch[MAX_SIZE];\\n  int len;\\n} String\\n\\n链串\\n\\n线性字符串\\n\\ntypedef struct {\\n  char * ch;\\n  int len;\\n} String\\n\\n块链串\\n\\ntypedef struct Block {\\n  char ch[BOLOCK_SIZE];\\n  struct Block * next;\\n} Block;\\n\\ntypedef struct {\\n  Block * head;\\n  Block * tail;\\n  int len;\\n} String\\n\\n模式匹配\\n...","tags":[{"slug":"data-structure","raw":"data structure"}],"categories":[{"slug":"computer-science","raw":"computer science","children":[{"slug":"computer-science/data-structure","raw":"data structure","children":[{"slug":"computer-science/data-structure/string","raw":"string","children":[]}]}]}],"createdAt":"2019-10-24T19:30:32.000Z"},"/posts/2019/10/28/browser-rendering-process.html":{"url":"/posts/2019/10/28/browser-rendering-process.html","title":"从 url -> 网页","excerpt":"从 url -> 网页\\n1. 请求内容\\n2. 构建朴素的 DOM 树\\n  流式解析\\n3. 计算 CSS\\n  流式渲染\\n  渲染顺序\\n  选择器\\n  没有父选择器\\n4. 渲染\\n  盒模型\\n  排版\\n  流式渲染\\n5. 位图合成(可选)\\n6. 绘制\\n\\n1. 请求内容\\n\\nHTTP / HTTPS 请求数据, url -> 文本内容\\n\\n2. 构建朴素的 DOM 树\\n\\n流式解析\\n\\n状态机分词: https://github.com/aimergenge/toy-html-parser\\n\\n3. 计算 CSS\\n\\n流式渲染\\n\\n每生成一个dom节点, 便立刻去匹配相应的css规则\\n\\n渲染顺序\\n\\n父节点 -> 子节点\\n\\n选择器\\n\\n混合选择器\\n\\n在激活的时候父元素已经确定好了\\n\\n后代选择器\\n\\n所有元素都是父元素，并选中自己的子元素\\n\\n子元素选择器\\n\\n只有父元素为当前节点的 dom  元素会被选中\\n\\n在父元素结束标签时，关闭选择器\\n\\n没有父选择器\\n\\n在保证选择器在 DOM 树构建到当前节点时, 已经可以准确判断是是否匹配, 不需要后续节点信息, 保证了上述三条的正常工作\\n\\n4. 渲染\\n\\n作用 得到内存中的位图...","tags":[{"slug":"browser","raw":"Browser"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/front-end","raw":"Front End","children":[]}]}],"createdAt":"2019-10-28T00:00:00.000Z"},"/posts/2019/10/28/browser-same-origin-policy.html":{"url":"/posts/2019/10/28/browser-same-origin-policy.html","title":"浏览器同源政策","excerpt":"判断方式\\n\\n协议相同\\n域名相同\\n端口相同\\n\\nCookie、LocalStorage 和 IndexDB 无法读取\\n\\nCookie 只有同源的网页才能共享\\n\\n如果一级域名相同, 可以将两个页面设置相同的 domain 共享 Cookie\\n\\ndocument.domain = 'example.com'; // 指定Cookie的所属域名为一级域名\\n\\nDOM 无法获得\\n\\n以下代码受到限制\\n\\ndocument.getElementById(\\"myIFrame\\").contentWindow.document\\nwindow.parent.document.body\\n\\n解决方法\\n\\n一级域名相同\\n\\ndocument.domain = 'example.com'; // 两个网站都需要设置, 且完全相等\\n\\n一级域名不相同\\n\\n片段识别符\\n\\n原理: 只改变片段标识符，不会引起页面刷新\\n\\n父窗口写 URL#hash\\n子窗口监听 hashchange\\n\\nwindow.name\\n\\n原理: window.name容量很大，可以放置非常长的字符串\\n\\n缺点: 必须监听子窗口window.name属性的变化，影响网页...","tags":[{"slug":"browser","raw":"Browser"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/front-end","raw":"Front End","children":[]}]}],"createdAt":"2019-10-28T00:00:00.000Z"},"/posts/2019/12/08/basic-grammar-of-typescript.html":{"url":"/posts/2019/12/08/basic-grammar-of-typescript.html","title":"TypeScript 基本语法","excerpt":"TypeScript Language Specification\\n\\nType\\n\\nEnum\\n\\nenum Tristate {\\n  False,\\n  True = 2,\\n  Unknown,\\n}\\n\\nconst lie = Tristate.False\\n\\n// compiled, 生成一个全局变量\\nvar Tristate\\n;(function (Tristate) {\\n  Tristate[(Tristate[\\"False\\"] = 0)] = \\"False\\"\\n  Tristate[(Tristate[\\"True\\"] = 2)] = \\"True\\"\\n  Tristate[(Tristate[\\"Unknown\\"] = 3)] = \\"Unknown\\"\\n})(Tristate || (Tristate = {}))\\n\\nvar lie = Tristate.False\\n\\nconst enum : 编译后不包含全局变量, 而是直接替换为值, 减少寻址过程 var lie = 0, 可以添加编译选项--preserveConstEnums生成全局变量\\n\\nInterface\\n\\n不以 I 开头, 因为并不仅...","tags":[{"slug":"typescript","raw":"TypeScript"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/front-end","raw":"Front End","children":[]}]}],"createdAt":"2019-12-08T00:00:00.000Z"},"/posts/2019/12/08/note-for-vue2.html":{"url":"/posts/2019/12/08/note-for-vue2.html","title":"Vue 2","excerpt":"语法\\n\\n属性\\n\\ndata\\n  原生属性\\n    特殊: class, style\\n  data\\nprops\\n\\n  VUE 如何监听子组件改变 Props?\\n\\nvuex\\n\\n事件\\n\\n普通事件\\n  $emit 是否存在返回值\\n修饰符事件\\n\\n插槽\\n\\n普通插槽\\n作用域插槽\\n  相同名称的插槽是合并还是覆盖\\n\\nView -> Model\\n\\nMVVM\\n\\n数据驱动\\n\\nnew Vue\\n\\nmegerConfiguration()\\n\\ninitLifecycle(vm) {\\n  initEvents(vm)\\n  initRender(vm)\\n  callHook(vm, 'beforeCreate')\\n  initInjections(vm) // resolve injections before data/props\\n  initState(vm)\\n  initProvide(vm) // resolve provide after data/props\\n  callHook(vm, 'created')\\n}\\n\\n$mount\\n\\nrender\\n\\nconst mount = Vue.prototype.$mo...","tags":[{"slug":"vue","raw":"Vue"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/front-end","raw":"Front End","children":[]}]}],"createdAt":"2019-12-08T00:00:00.000Z"},"/posts/2019/12/15/http-protocol.html":{"url":"/posts/2019/12/15/http-protocol.html","title":"HTTP协议","excerpt":"基本结构\\n\\nRequest\\n\\nhttp request\\n1. 换行为 \\\\r\\\\n (CRLF)\\n2. header 与 body 间存在 blank line\\n\\nGET /search?hl=zh-CN&source=hp&q=domety&aq=f&oq= HTTP/1.1\\nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,\\napplication/msword, application/x-silverlight, application/x-shockwave-flash, /\\nReferer: http://www.google.cn/\\nAccept-Language: zh-cn\\nAccept-Encoding: gzip, deflate\\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2....","tags":[{"slug":"http","raw":"HTTP"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/network","raw":"Network","children":[]}]}],"createdAt":"2019-12-15T10:45:02.000Z"},"/posts/2019/12/18/tcp-protocol.html":{"url":"/posts/2019/12/18/tcp-protocol.html","title":"TCP协议","excerpt":"Transmission Control Protocol，传输控制协议。TCP 属于传输层通信协议，基于TCP的应用层协议有: HTTP(s)，SMTP，FTP，Telnet 和 POP3等。\\n\\n优点: 提供可靠传输，具有拥塞控制\\n\\n缺点: 传输效率低，慢启动\\n\\n特点\\n\\n面向连接：使用 TCP 传输数据前，需先建立连接，传输完成后需释放连接。\\n\\n全双工通信：建立 TCP 连接后，双方都可以发送数据\\n\\n可靠通信：TCP协议保证数据不丢失，无差错，不重复且按序到达\\n\\n面向字节流：数据以流的形式传输\\nTCP 会将数据报文分为数据段(data segment)传输，但由于其可靠性，上层可将其视为字节流传输\\n\\n报文格式\\n\\nTCP Header - 20 byte\\n\\n报文首部最小长度为20字节\\n\\n源端口，目的端口：\\n表明发送端所使用的端口号和要连接的目标主机的端口号，不包含IP地址。\\n\\n序号（seq）：\\n表明发送的数据包的顺序，一般为上次发送包中的顺序号+1。\\n若该数据包是整个TCP连接中的第一个包（SYN包），则该值是随机生成的。\\n\\n确认号（ack）：\\n表明本端TCP已经接收到的数据，其值表示...","tags":[{"slug":"network","raw":"Network"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/network","raw":"Network","children":[]}]}],"createdAt":"2019-12-18T09:56:00.000Z"},"/posts/2020/12/31/binary-system.html":{"url":"/posts/2020/12/31/binary-system.html","title":"计算机中数据的表示","excerpt":"基本概念\\n\\n真值：带符号的数字：-1、-2、+2\\n\\n原码：最高位表示符号，0表示正、1表示负，其中0,000和1,0...0都表示数字0（逗号前为符号），表示范围在数轴上关于原点对称\\n\\n反码：除符号位外取反，如 1,010101 （原）-> 1,101010（反），其中依然有两个零，表示范围关于原点对称\\n\\n补码：反码+1得补码，如  1,010101 （原）-> 1,101011（移），其中零只有一个，因此表示得负数比正数多一个（全0表示-2^n）\\n\\n移码：移码是表示范围在在数轴上偏移，移码大，真值就大，移码常常用来表示浮点数的阶码，加快比较。\\n\\n浮点数\\n\\nIEEE 754\\n\\n| 名称     | 尾数符号位 | 尾数 | 阶码 | 阶码偏移值 | 隐藏位 |\\n| -------- | ---------- | ---- | ---- | ---------- | ------ |\\n| 短浮点数 | 1          | 23   | 7    | 2^7-1      | Yes    |\\n| 长浮点数 | 1          | 52   | 11   | 2^10-1   ...","tags":[{"slug":"computer-organization","raw":"Computer Organization"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-organization","raw":"Computer Organization","children":[]}]}],"createdAt":"2020-12-31T15:38:28.000Z"},"/posts/2021/01/01/instruction-fetch.html":{"url":"/posts/2021/01/01/instruction-fetch.html","title":"取指周期","excerpt":"取指是指处理器核将指令从存储器中读取出来的过程（按照其指令PC值所对应的存储器地址\\n\\n取指的终极目的是以最快的速度且连续不断地从存储器中取出指令供处理器核执行，为了达到这两个目标，我们需要达到如下性能：\\n\\n对于非分支跳转指令，能够连续不断的按顺序将其从存储器中快速读取出来，即便是地址不对其的指令，也最好能够连续不断的从每个周期读出一条指令\\n对于分支跳转指令，能够快速判断其是否需要跳转，并快速取出指令\\n\\n如何加快取值\\n\\nITCM（Instruction Tightly Coupled Memory）\\n\\nITCM（指令紧耦合寄存器）是指配置一段较小容量的（一般几十KB）的存储器（通常使用SRAM），用于存储指令，且在物理上离处理器核近而专属于处理器核。大多数极低功耗的处理器应用场景都是实时性较高的场景，因此倾向于使用延迟确定的ITCM。\\n\\n优点：实现简单，容易理解，能够保证实时性\\n\\n缺点：使用地址区间寻址（无法像Cache一样映射无限大的存储空间），容量小（保证访问能在一个时钟周期内完成）\\n\\nI-Cache（Instruction Cache）\\n\\n指令缓存，是指利用软件程序的时间局部性和空...","tags":[{"slug":"computer-organization","raw":"Computer Organization"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-organization","raw":"Computer Organization","children":[]}]}],"createdAt":"2021-01-01T00:00:00.000Z"},"/posts/2021/01/02/angularjs-git-commit-message-conventions.html":{"url":"/posts/2021/01/02/angularjs-git-commit-message-conventions.html","title":"Git Angular 规范","excerpt":"via: Git Commit Message Conventions\\n\\nGit 中每次 commit，都需要书写 commit message：\\n\\ngit commit -m \\"hello world\\"\\n\\n每次使用 git log 时，一份清晰的commit message 可以帮助我们快速找到所需的 commit，AngularJS Git Commit Message Conventions 就是帮助你写好它。\\n\\n目标\\n\\n提供更多的历史信息，方便浏览\\n允许过滤 commit 便于查找\\n可以通过脚本生成 Change log\\n\\n格式\\n\\nMessage 由 Header、Body（Optional）和 Footer（Optional）组成，通过空行连接：\\n\\n():\\n\\n同时，每行不应超过100字符，这是避免自动换行影响美观。\\n\\nMessage Header\\n\\nHeader 只有一行，由 type、scope（optional）和 subject 组成。\\n\\ntype\\n\\n规定的类型如下：\\n\\nfeat：新功能（feature）\\nfix：修补bug\\ndocs：文档（documentation）...","tags":[{"slug":"git","raw":"git"}],"categories":[{"slug":"computer-science","raw":"computer science","children":[]}],"createdAt":"2021-01-02T16:01:28.000Z"},"/posts/2021/01/02/avl-tree.html":{"url":"/posts/2021/01/02/avl-tree.html","title":"平衡二叉树（AVL树）","excerpt":"平衡二叉查找树，简称：平衡二叉树，由前苏联的数学家 Adelse-Velskil 和 Landis 在1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为AVL 树。指的是所有节点平衡因子的绝对值不大于1的二叉树叫做平衡二叉树。\\n\\n你可以通过 AVL Tree Visualzation 来模拟AVL树的各个操作。\\n平衡因子：左子树高减去右子树高\\n平衡二叉树并不一定是一个完全二叉树，例如高度为4且非叶子节点平衡因子均为1的AVL树\\nimage-20210115121840387\\n由上图我们还可以发现，高度为4的AVL树最少有7个节点，最多有15个节点\\n\\n插入\\n\\n插入操作与二叉排序树相似，但插入后可能引起失衡。\\n\\n通过排序规则选择合适的插入位置\\n创建一新的叶子节点，插入该位置\\n向上更新路径上每个节点的平衡因子，当平衡因子的绝对值大于1时引起失衡，先进行平衡操作\\n重复步骤3，直到达到根节点\\n\\n删除\\n\\n插入操作与二叉排序树相似，但插入后可能引起失衡。\\n\\n通过查找规则找到删除节点，找不到则结束，如果为只有一个节点的树的根节点，则删除根节点后结束\\n找到删除节点在中序遍历中的前驱节点或后继节...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/tree","raw":"Tree","children":[]}]}]}],"createdAt":"2021-01-02T14:00:00.000Z"},"/posts/2021/01/02/binary-sort-tree.html":{"url":"/posts/2021/01/02/binary-sort-tree.html","title":"二叉排序树","excerpt":"查找：$O(log_2 n)$，最差可能退化到 $O(n)$\\n\\n删除结点 p\\n\\n// f 为 p 的父结点\\n// s 为中序序列中 p 的前驱结点\\n// q 为 s 的父结点\\n\\n// one way\\nf->lchild = p->lchild;\\ns->rchild = p->rchild;\\nfree(p);\\n\\n// another way\\np->data = s->data;\\nq->rchild = s->lchild;\\nfree(s);...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/tree","raw":"Tree","children":[]}]}]}],"createdAt":"2021-01-02T14:00:00.000Z"},"/posts/2021/01/02/huffman-tree.html":{"url":"/posts/2021/01/02/huffman-tree.html","title":"哈夫曼树（Huffman Tree）","excerpt":"定义：n 个带权叶子结点构成的所有 m 叉树中带权路径长度最短的 m 叉树\\nWPL：带权路径长度（Weighted Path Length）\\n\\n构造步骤（贪心）\\n\\n初始化：由 n 个权值构造二叉树森林$\\\\{ T_1, T_2, T_3... \\\\}$\\n补空节点（二阶哈夫曼树跳过）：补 k 个空节点，使得(n+k-1)%(m-1)==0\\n由哈夫曼树只有度为 0 和 m 的节点，又\\n$$n_0+n_1+n_2+...+n_m=0n_0+1n_1+2n_2+...+mn_m+1$$\\n故：\\n$$n_0-1=(m-1)*n_m$$\\n找最小树：在森林中选择根结点权值最小的两棵树，构造新二叉树，根结点权值为左右子树根结点权值之和\\n删除与加入：在森林中删除选中的两棵树，加入新树\\n判断：重复步骤 3、4，直至只剩一棵树，即为哈夫曼树\\n\\n储存结构\\n\\n由定义可知，\\n\\n|               | 数量 |\\n| ------------- | ---- |\\n| 叶子          | n    |\\n| 结点          | 2n+1 |\\n| 度为 1 的结点 | 0    |\\n| 度为 2 的结...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/tree","raw":"Tree","children":[]}]}]}],"createdAt":"2021-01-02T14:00:00.000Z"},"/posts/2021/01/02/tree-and-forest.html":{"url":"/posts/2021/01/02/tree-and-forest.html","title":"树和森林","excerpt":"树（Tree）\\n\\n树是 n (n>=0) 个结点的有限集合 T. 当 n=0 时，称为空树; 当 n>0 时，集合满足下列条件:\\n\\n有且仅有一个特定的称为根（root）的结点，它没有直接前驱，但有零个或多个直接后继\\n当 n>1 时，其余结点可分为 m（m>0）个互不相交的有限集 $T_1, T_2, \\\\ldots T_m$，其中每一个集合本身又是一棵树，并且称为根的子树\\n\\n将树视为特殊的无向图，有：图的出度等于入度；又树中除根结点外，入度均为 1，故有：\\n\\n$$n_0 + n_1 + n_2 + \\\\ldots + n_k = 0 * n_0 + 1 * n_1 + 2 * n_2 + \\\\ldots + k * n_k + 1$$\\n\\n其中 $n_i$ 表示度数为 $i$ 的结点。\\n\\n二叉树（Binary Tree）：度不大于 2 的有序树（左右节点有序）\\n\\n满二叉树：深度为 k 且有 $2^k-1$ 个结点的二叉树\\n\\n完全二叉树：深度为 k，结点数为 n 的二叉树，当且仅当其 1  n 都与深度为 k 的满二叉树中编号从 1  n 的结点一一对应时，则称之为完全二叉树\\n\\n性质\\n\\n性质一：...","tags":[{"slug":"data-structure","raw":"Data Structure"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/tree","raw":"Tree","children":[]}]}]}],"createdAt":"2021-01-02T14:00:00.000Z"},"/posts/2021/01/20/coffee.html":{"url":"/posts/2021/01/20/coffee.html","title":"咖啡与咖啡文化","excerpt":"咖啡（coffee）是采经过烘焙过程的咖啡豆所制作冲泡的饮料，是人类社会流传最为广泛的饮料之一，也是重要的经济作物，其为全球期货贸易额度第二高（最高为石油）。\\n\\n咖啡属\\n\\n咖啡豆是将咖啡树果实中的种子烘焙而得到的。咖啡树隶属于咖啡属，咖啡属内大约有有70多种，其中用于商业用途的主要是阿拉比卡种和卡内弗拉种。卡内弗拉种常常被人们称为罗布斯塔种，但其实罗布斯塔种只是其中一个分支，因为广为人知，所以罗布斯塔种渐渐成了卡内弗拉种的代名词。\\n\\n阿拉卡比种占咖啡产值的65%，又称小果咖啡，有铁皮卡（Typica）、波旁（Bourbon）等众多品种。单就成分来看，阿拉卡比豆咖啡因含量较低，比例大约在0.9%~1.2%之间，脂肪和糖的含量相当丰富，因此气味柔和、不刺激，口感清新微甜，有时会带一些清爽怡人的酸味，受到绝大多数咖啡爱好者的喜爱。虽然此品种拥有广受好评的味道，但是也有易染病害的弱点。\\n\\n卡内弗拉种占目前咖啡产值的35%，卡内弗拉种颗粒较粗，故又称中果咖啡。它的特点是独特的大麦茶香和比较重的苦味，同时又有较强的抗病性。在1900年阿拉卡比豆遭受严重病害时，卡内弗拉种得到了广泛的普及。\\n\\n├─ ...","tags":[{"slug":"coffee","raw":"Coffee"}],"categories":[{"slug":"life","raw":"Life","children":[{"slug":"life/coffee","raw":"Coffee","children":[]}]}],"createdAt":"2021-01-20T18:21:53.000Z"},"/posts/2021/02/14/b-tree.html":{"url":"/posts/2021/02/14/b-tree.html","title":"B树的插入与删除","excerpt":"B 树是一种自平衡树，能够保持数据的有序，且拥有良好的查找性能和更少的读盘次数，常用于文件系统和数据库的设计实现中。B 树由二叉树发展而来，平衡二叉树在查找性能达到了对数时间 $log_{2}n$，在内部查找时十分高效，但是在外部查找中由于 $t_{IO}>>t_{search}$，人们希望设计一种能够尽可能减少读盘次数的数据结构。顺着二叉树的思路，人们在二叉树的基础上该进得到了 B 树（m 叉查找树），将树高降到了 $log_{m}n$。\\n\\n\\n\\n\\n\\n一个 $m$ 阶的 $B$ 树是有以下属性的树：\\n\\n每一个节点最多有 $m$ 个子节点；\\n每一个节点（除根节点）最少有 $\\\\lfloor m/2 \\\\rfloor$ 个子节点；\\n如果根节点不是叶子节点，那么它至少有两个子节点\\n有 $k$ 个子节点的非叶子节点拥有 $k-1$ 个键\\n所有的叶子节点都在同一层\\n\\n其中性质 2 和性质 4 的约束使 $B$ 树至少为一颗半满的树来保证存储密度；$B$ 树的叶子节点通常指的是额外填充的空节点，当查找操作到达空节点时，即代表查找失败，这一层叶节点可以计入 $B$ 树的高度，也可以不计入。\\n\\n查找\\n\\n$...","tags":[{"slug":"data-structure","raw":"Data Structure"},{"slug":"tree","raw":"Tree"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/data-structure","raw":"Data Structure","children":[{"slug":"computer-science/data-structure/tree","raw":"Tree","children":[]}]}]}],"createdAt":"2021-02-14T00:00:00.000Z"},"/posts/2021/02/15/how-to-read-a-book.html":{"url":"/posts/2021/02/15/how-to-read-a-book.html","title":"如何阅读一本书","excerpt":"阅读的活力与艺术\\n\\n在某种范围内，知识（knowledge）也成了理解（understanding）的先决条件，但我们为了理解（understand）一件事，并不需要知道（know）和这件事相关的所有事。\\n\\n太多的资讯就如同太少的资讯一样，都是对理解力的阻碍。\\n\\n阅读的目的：为获得资讯而读，以及为求得理解而读。阅读的人一定要把不相等的理解力克服到一定程度之内。\\n\\n阅读就是学习：指导型的学习与自我发现型的学习，区别只在于老师的出席与否。\\n争论可能来自偏见或情绪化、知识的不相当、或是被深深地隐藏起来，只要排除误解，增加知识就能解决这些争论。这两种解药尽管经常很困难，通常却都管用。\\n\\n主动阅读：做一个自我要求的读者\\n\\n阅读可以是一件多少主动的事情；阅读越主动，效果越好；努力越多，效果越好。\\n\\n主动阅读的基础：一个阅读者要提出的四个基本问题——在阅读的过程中，你自己必须尝试去回答的问题：\\n\\n整体来说，这本书到底在谈些什么？\\n作者细部说了什么，怎么说的？\\n这本书说的有道理吗？是全部有道理，还是部分有道理？\\n这本书跟你有什么关系？\\n第四个问题区分了讯息（information）与理解（unders...","tags":[],"categories":[{"slug":"life","raw":"Life","children":[]}],"createdAt":"2021-02-15T11:00:15.000Z"},"/posts/2021/02/16/propositional-calculus.html":{"url":"/posts/2021/02/16/propositional-calculus.html","title":"命题逻辑","excerpt":"命题是用陈述句表示的一个判断结果唯一的判断语句。\\n- ”除地球外的星球没有生命\\"是命题，但真值未知\\n- “3-x=5”不是命题，真值不唯一\\n- “几点了？”不是命题，疑问句\\n- “多漂亮的花啊！”不是命题，感叹句\\n- “我只给所有不给自己理发的人理发”不是命题，悖论\\n\\n命题变量\\n\\n我们可以将一个命题符号化，通常用 $p, q, r, \\\\dots$ 表示。代表特定简单命题且真值确定的符号称为命题常元，而代表任意命题且取值不确定的符号称为命题变元，表示一个取值 1（真）或 0（假）的变量。命题变元没有真值，只有表示一个明确的命题后才有真值。\\n\\n联结词\\n\\n命题分为简单命题（原子命题）和复合命题，命题可以通过英文字母或英文字母和联结词来表示，称为命题符号化。\\n\\n常用联结词有否定 $\\\\lnot$、合取 $\\\\land$、析取 $\\\\lor$、蕴涵 $\\\\rightarrow$ 和等价 $\\\\leftrightarrow$ 联结词，其他联结词还有与非 $\\\\uparrow$、或非 $\\\\downarrow$ 和异或 $\\\\oplus$。上述联结词真值表如下：\\n\\n|  $p$  |  $q$  | $\\\\lnot ...","tags":[{"slug":"discrete-mathematical","raw":"discrete mathematical"}],"categories":[{"slug":"math","raw":"math","children":[{"slug":"math/discrete-mathematical","raw":"discrete mathematical","children":[]}]}],"createdAt":"2021-02-16T16:42:00.000Z"},"/posts/2021/02/26/regular-grammar-and-automata.html":{"url":"/posts/2021/02/26/regular-grammar-and-automata.html","title":"正规文法与自动机","excerpt":"正规文法（Regular Grammar）指的是一种特殊的文法，其对上下文无关文法加以限制，由于限制较多，很难用于表示现有语法，但其常常被用于构建正则表达式（Regular Expression），用来匹配检索和替换某个模式的文本。\\n\\n\\n\\n\\n\\n文法是用来描述一个语言句子集合的规则，文法 G 定义为四元组 $(V_N, V_T, P, S)$，其中 $V_N$ 为非终结符（或语法实体，或变量）；$V_T$ 为终结符集；$P$ 为规则 $(\\\\alpha \\\\rightarrow \\\\beta)$ ；$S$ 称为开始符，是一个非终结符。\\n\\n文法可以分为 4 种，分别为 0 型文法（无限制文法）、1 型文法（上下文相关文法，Context Sensitive）、2 型文法（上下文无关文法，Context Free）和 4 型文法（正规文法）。\\n\\n上下文无关文法（CFG）的产生式是 $\\\\alpha _1 A \\\\alpha _2 \\\\rightarrow \\\\alpha _1 B \\\\alpha _2$，即在指定的上下文 $\\\\alpha _1, \\\\alpha _2$ 中，可以由 $A \\\\rightarrow...","tags":[{"slug":"automata","raw":"Automata"},{"slug":"compiler","raw":"Compiler"}],"categories":[],"createdAt":"2021-02-26T00:00:00.000Z"},"/posts/2021/03/03/some-regular-grammar.html":{"url":"/posts/2021/03/03/some-regular-grammar.html","title":"一些正则语法及其自动机","excerpt":"识别标识符\\n\\n$$\\n\\\\begin{align}\\ndigit &\\\\rightarrow 0|1|\\\\dots |9 \\\\\\\\\\nletter\\\\_ &\\\\rightarrow A|B|\\\\dots |Z|a|b|\\\\dots |z|\\\\_ \\\\\\\\\\nid &\\\\rightarrow letter_(letter_|digit)*\\n\\\\end{align}\\n$$\\n\\n识别无符号数\\n\\n$$\\n\\\\begin{align}\\ndigit &\\\\rightarrow 0|1|\\\\dots |9 \\\\\\\\\\ndigits &\\\\rightarrow digit* \\\\\\\\\\noptionalFraction &\\\\rightarrow .digits|\\\\epsilon \\\\\\\\\\noptionalExponent &\\\\rightarrow (E(+|-|\\\\epsilon ) digits)| \\\\epsilon \\\\\\\\\\nnumber &\\\\rightarrow digits\\\\ optionalFraction\\\\ optionalExponent\\n\\\\end{align}\\n$$\\n\\n识别各进制无符号数\\n\\n$$\\n\\\\begin{align}\\nDEC &\\\\rightarro...","tags":[],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/compiler","raw":"Compiler","children":[]}]}],"createdAt":"2021-03-03T00:00:00.000Z"},"/posts/2021/03/08/top-down-grammar-parsing.html":{"url":"/posts/2021/03/08/top-down-grammar-parsing.html","title":"自顶向下的语法分析","excerpt":"语法分析是编译程序的核心功能，其作用是识别由词法分析给出的单词符号串是否是给定文法的句子。语法分析通常可以分为自顶向下的分析方法和自底向上的分析方法，自顶向下的方法虽然可以分为不确定和确定的两类，但是在编译器中基本只见得到确定分析方法。\\n\\n不确定的自顶向下分析\\n\\n不确定的自顶向下方法，就是带有回溯的分析方法，实际上也就是一种穷举的试探方法，效率低，代价高，因此极少使用。\\n\\n不确定的分方法不常用的主要原因就是回溯，回溯指的是回到之前的状态，从输入字符串角度考虑，需要不停的退回到之前的输入中，效率非常差，而且需要额外的代价存储之前的状态。因此，我们通常希望寻找一种线性时间的无回溯的算法。回溯常常由以下问题导致：\\n\\n由于FIRST集相交引起回溯\\n\\n文法中具有相同左部的产生式的 $FIRST$ 集交集不为空可能引起回溯，考虑下列文法：\\n$$\\n\\\\begin{aligned}\\nS &\\\\rightarrow xAy \\\\\\\\\\nA &\\\\rightarrow ab|a\\n\\\\end{aligned}\\n$$\\n\\n其中非终结符 A 有两条产生式，且具有相同的 $FIRST$ 集 $\\\\{ a \\\\}$。若当前输入串为 x...","tags":[{"slug":"grammar","raw":"Grammar"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/compiler","raw":"Compiler","children":[]}]}],"createdAt":"2021-03-08T19:50:16.000Z"},"/posts/2021/03/10/implement-of-ll1-grammar.html":{"url":"/posts/2021/03/10/implement-of-ll1-grammar.html","title":"LL(1) 文法的实现","excerpt":"文法实现可以分为递归和非递归（表驱动）的实现方法，二者性能表现如下：\\n\\n|          | 递归的预测分析法 | 表驱动的预测分析法                   |\\n| -------- | ---------------- | ------------------------------------ |\\n| 程序规模 | 程序规模较大     | 程序规模较小，需加载分析表（表较小） |\\n| 直观性   | 较好             | 较差                                 |\\n| 效率     | 较低             | 分析程序正比于代码长度               |\\n| 自动生成 | 较难             | 较易                                 |\\n\\n递归下降预测分析程序\\n\\n表驱动的预测分析程序\\n\\n输入缓冲区和分析栈\\n\\n下推自动机\\n\\n错误处理\\n\\n错误检测\\n\\n两种情况下我们可以检测到错误：\\n\\n栈顶的终结符和当前输入符号不匹配\\n栈顶非终结符和当前输入符号在预测分析表对应项中的...","tags":[{"slug":"grammar","raw":"Grammar"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/compiler","raw":"Compiler","children":[]}]}],"createdAt":"2021-03-10T00:00:00.000Z"},"/posts/2021/03/11/clean-code.html":{"url":"/posts/2021/03/11/clean-code.html","title":"代码整洁之道","excerpt":"试想一段乱七八糟的代码，if/else、 for 和 switch 反复嵌套，代码需要翻上两三次才能看到底，可能还没有测试代码……\\n\\n毫无疑问，没有人愿意维护这样一段代码，每个接手它的人，都选择在复杂的分支条件中加上几句代码，而不愿意重构它，这样一段代码，将一个系统拉入深坑，直到没有人再愿意去维护它。虽然工程中告诉我们没有修改才是最稳定的，但是对于一段代码而言，没有重构也就意味着它彻底死去。\\n\\nClean code rules\\n\\n命名\\n\\n从写下第一行代码开始，命名就不断纠缠着程序员，作为”两大难题“之一，命名显得格外重要。\\nThere are only two hard things in Computer Science: cache invalidation and naming things.\\n-- Phil Karlton\\n\\n选取一个命名首先应该是一个有意义的命名，并且是一个没有误导性的名称：\\n\\naccountList 不是一个好名称，最好不要用一个list来表示一个列表，即使它真的是一个列表，它对程序员有特殊的意义，至少accounts都比它好\\na1 a2 也不是个好名称，除...","tags":[{"slug":"clean-code","raw":"Clean Code"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/coding-style","raw":"Coding Style","children":[]}]}],"createdAt":"2021-03-11T00:00:00.000Z"},"/posts/2021/03/11/naming-for-clean-code.html":{"url":"/posts/2021/03/11/naming-for-clean-code.html","title":"代码整洁之道——命名","excerpt":"Choose descriptive and unambiguous names.\\nMake meaningful distinction.\\nUse pronounceable names.\\nUse searchable names.\\nReplace magic numbers with named constants.\\nAvoid encodings. Don't append prefixes or type information.\\n\\n有意义的命名\\n\\n选取一个命名首先应该是一个有意义的命名，并且是一个没有误导性的名称：\\n\\naccountList 不是一个好名称，最好不要用一个list来表示一个列表，即使它真的是一个列表，它对程序员有特殊的意义，至少accounts都比它好\\na1 a2 也不是个好名称，除了循环变量常常是 i j k 外，尽量用一个有意义的名字\\nnameString 更离谱了，难不成 name 会是个浮点数？对了，还有 Variable Info……\\nHolyHandGrenade 说实话我查了会儿词典才懂得这和 DeleteItems 是一个意思，别用这类与文化紧...","tags":[{"slug":"clean-code","raw":"Clean Code"},{"slug":"naming","raw":"Naming"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/coding-style","raw":"Coding Style","children":[]}]}],"createdAt":"2021-03-11T17:12:23.000Z"},"/posts/2021/03/13/sdd-and-sdt.html":{"url":"/posts/2021/03/13/sdd-and-sdt.html","title":"SDD 与 SDT","excerpt":"SDD\\n\\n综合属性\\n\\n分析树节点N上的非终结符A的综合属性由N的子节点或N本身的属性来定义\\n\\n例如：产生式$E\\\\rightarrow E_1+T$ 的语义规则 $E.val=E_1.val+T.val$，E 的 val 值由子节点得到，因此为综合属性\\n\\n终结符也可以具有综合属性，为词法分析器提供的词法值，因此在SDD中没有计算终结符属性值的语义规则\\n\\n继承属性（inherited attribute）\\n\\n分析树节点N上的非终结符的继承属性由由N的父节点、N的兄弟节点或N本身的属性来定义\\n\\n例如：产生式 $D\\\\rightarrow TL$ 的语义规则 $L.inh=T.type$，L 的 inh 属性由兄弟节点 T 继承而来，因此为继承属性\\n\\n终结符没有继承属性，因为终结符的所有属性都是由词法分析器给出的综合属性（lexval）\\n\\n属性文法\\n\\n文法的产生式可以有一个副作用，没有副作用的文法称为属性文法\\n\\n求值顺序\\n\\n依赖图\\n\\n习惯上，将综合属性放在依赖图中节点右侧，继承属性放在左侧\\n\\n虚节点\\n\\n求值顺序就是依赖图的拓扑排序，对于同时有综合属性和依赖属性的节点，我们无法保证这个SDD一定存...","tags":[{"slug":"grammar","raw":"Grammar"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/compiler","raw":"Compiler","children":[]}]}],"createdAt":"2021-03-13T00:00:00.000Z"},"/posts/2021/03/16/is-it-an-ll1-grammar.html":{"url":"/posts/2021/03/16/is-it-an-ll1-grammar.html","title":"LL(1)文法判别","excerpt":"在 LR 分析中，首先应该判断一个文法是否为 LL(1) 文法，对此可以给出一些必要条件：\\n\\n含有左递归的文法绝对不是 LL(1) 文法\\n\\n同样也可以给出一些充分条件：\\n\\ns\\\\文法和 q\\\\文法是 LL1\\n\\n但是这些条件都无法在任意条件下判断一个 CFG 文法（上下文无关文法）是否是 LL(1) 的，还是要回到 LL(1) 文法定义：\\n假设文法 G 是 LL(1) 的，当且仅当 G 的任意两个具有相同左部的产生式 $A \\\\rightarrow\\\\alpha|\\\\beta$ ，有$SELECT(A \\\\rightarrow \\\\alpha) \\\\cap SELTCT(A \\\\rightarrow \\\\beta)=\\\\emptyset$，其中 $\\\\alpha$ 和 $\\\\beta$ 不能同时 \${\\\\Rightarrow}^* \\\\epsilon$。\\n\\n可以看出，要判别一个给定 Context Free Grammar G 是否为 LL(1) 文法的关键在于判断 SELECT 集是否相交，求解时可以分为几个步骤：\\n\\n求能够推出 ε 的非终结符\\n计算每一个文法符号的 FIRST 集\\n\\n计算每个非终结符的 FOLLO...","tags":[{"slug":"grammar","raw":"Grammar"},{"slug":"compiler","raw":"Compiler"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/compiler","raw":"Compiler","children":[]}]}],"createdAt":"2021-03-16T14:07:03.000Z"},"/posts/2021/03/19/down-top-grammar-analysis.html":{"url":"/posts/2021/03/19/down-top-grammar-analysis.html","title":"自底向上的语法分析","excerpt":"自底向上的语法分析采用最左归约方式，也就是反向构造最右推导，其具体实现有优先分析和LR分析。优先分析中又有简单优先分析和算符优先分析。简单优先分析的分析过程准确、规范，但是效率低，没有实用价值，而算符优先分析虽然分析速度快，但是不是规范归约，仅有一定应用，本文主要介绍LR分析。\\n\\n移入-归约分析（Shift-Reduce Parsing）\\n\\n实现自底向上分析最常用的技术是移入-归约分析\\n\\n最左规约\\n\\n句柄：当前句型的最左直接短语\\n\\n在分析过程中，句柄是逐步形成，移进状态、待约状态、规约状态\\n\\nShift Reduce Parsing Example\\n\\n优先分析\\n\\n简单优先分析\\n\\n算符优先分析\\n\\nLR 分析法\\n\\nLR(k)文法是最大的、可以构造出相应移入-规约语法分析器的文法类，L表示从左到右扫描，R表示反向构造出一个最右推导序列，k表示向前看k个输入符号，k=0 或 1 具有实践意义，省略 k 时表示 k=1\\n\\nLR 分析表\\n\\n符号栈、状态栈，ACTION 函数，GOTO 函数\\n\\nLR(0) 分析\\n\\n可归前缀：可归前缀指的是在规范句型中可以采用归约动作的前缀，一旦出现可归前缀，可以立刻...","tags":[{"slug":"compiler","raw":"Compiler"},{"slug":"grammar","raw":"Grammar"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/compiler","raw":"Compiler","children":[]}]}],"createdAt":"2021-03-19T00:00:00.000Z"},"/posts/2021/05/22/vue-conf-21.html":{"url":"/posts/2021/05/22/vue-conf-21.html","title":"Vue Conf 21","excerpt":"Vite\\n\\n为什么更快？\\n\\nVite 快速的核心原因时改变了原有的 Bundler-Based Dev Server，而采用 ESM-Based Dev Server 方案。Bundle-Base 的方案中，Full Bundler 决定了开发服务器的每次启动都十分低效，需要从入口文件解析整个依赖树并将其打包。而全新的 ESM-Based 开发服务器只需要做每个文件的 Transform，文件依赖解析则交由 ESM 完成，如此一来，开发服务器真的就只需要监听一个端口那么简单！\\n其实可能还有依赖预构建，当然这也是为了更快\\n\\nSSR 目标\\n\\nDev Bundless\\nNode 环境下加载 ESM\\n  兼容 Node 低版本\\n  兼容生态环境\\n支持 HMR+Plugin\\n\\n编译优化思路\\n\\nreturn {\\n  c() {\\n    /* create  */\\n  },\\n  m() {\\n    /* mount   */\\n  },\\n  p() {\\n    /* patch   */\\n  },\\n  d() {\\n    /* destory */\\n  },\\n}\\n\\n// @vue/reactive\\nr...","tags":[{"slug":"vue","raw":"vue"},{"slug":"vueconf","raw":"vueconf"},{"slug":"frontend","raw":"frontend"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/frontend","raw":"FrontEnd","children":[{"slug":"computer-science/frontend/vue","raw":"Vue","children":[]}]}]}],"createdAt":"2021-05-22T00:00:00.000Z"},"/posts/2021/06/19/rust-and-ownership.html":{"url":"/posts/2021/06/19/rust-and-ownership.html","title":"Rust 与 Ownership","excerpt":"所有权系统是 Rust 最具特色的地方，其理念并不复杂：任何变量都有所有权，没有所有权就不能用它。但是其理念深刻左右了 Rust 处处设计。\\n\\n简单的生命周期\\n\\n一个变量最简单的生命周期应该包含了 before created、created、droped\\n\\n{                      // s 在这里无效, 它尚未声明\\n    let s = \\"hello\\";   // 从此处起，s 是有效的\\n    // 使用 s\\n}                      // 此作用域已结束，s 不再有效\\n\\n这个变量将在堆上创建一个变量区域，当离开作用域后被释放。代码常常不是这么理想，现在我们需要将一个变量赋值给另一个变量。\\n\\nlet s1 = String::from(\\"hello\\");\\nlet s2 = s1;\\nprintln!(\\"{}, world!\\", s1);\\n\\n然后编译它：\\n\\nerror[E0382]: use of moved value: s1\\n --> src/main.rs:5:28\\n  |\\n2 |     let s2 = s1;\\n  |       ...","tags":[{"slug":"rust","raw":"Rust"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/language","raw":"Language","children":[{"slug":"computer-science/language/rust","raw":"Rust","children":[]}]}]}],"createdAt":"2021-06-19T00:00:00.000Z"},"/posts/2021/06/29/learn-sql-in-10-minutes.html":{"url":"/posts/2021/06/29/learn-sql-in-10-minutes.html","title":"Learn SQL in 10 Minutes","excerpt":"芜湖，好大的名字，不过只是原书部分摘抄 :blush:\\n\\n分组与聚集函数\\n\\n聚集函数\\n\\n与函数不同，聚集函数在多数DBMS上兼容，主要有MAX, MIN, SUM, AVG五个\\n多数聚集函数都会忽略值为NULL的行，包括MAX, MIN, SUM, AVG\\n如果不指定列名COUNT(*)会计算所有列，但如果指定列名COUNT(COLUMN_NAME)则会忽略该列中为NULL值的行\\n\\nHAVING与WHERE\\n\\nHAVING 和 WHERE 非常相识，如果不指定 GROUP BY ，多数 DBMS 同等对待它们。不过，你需要区分它们，HAVING 应结合 GROUP BY，而 WHERE 用于标准的行级过滤。\\n\\n对于二者的区别，最简单的解释是 WHERE 在 GROUP 前过滤，而 HAVING 在 GROUP 后过滤，也就是说 WHERE 排除的行不被包括在 GROUP 内。考虑下列代码：\\n\\nSELECT vend_id, COUNT(*) AS num_prods\\nFROM Products\\nWHERE prod_price >= 4\\nGROUP BY vend_id\\nHAVING ...","tags":[{"slug":"sql","raw":"SQL"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/language","raw":"Language","children":[{"slug":"computer-science/language/sql","raw":"SQL","children":[]}]}]}],"createdAt":"2021-06-29T00:00:00.000Z"},"/posts/2021/09/07/matrix-theory-1.html":{"url":"/posts/2021/09/07/matrix-theory-1.html","title":"高等代数基础","excerpt":"高等代数 = 线性代数（Linear  algebra）+ 多项式（Polynomial algebra）\\n\\nRank（秩）\\n\\nRank（排序），常见定义最高非零子式的阶数，但如果来看一个矩阵乘法 $PAQ = \\\\begin{pmatrix}I_r & 0 \\\\\\\\ 0 & 0\\\\end{pmatrix}$，其中，$I_r$ 中 I 为 Identity，表示一个恒元，而 r 就是表示其阶数，也就是秩。\\n相抵：$PAQ$\\n相合：$P'AP$\\n相似：$P^{-1}AP$\\n\\n为什么0不能呢做除数\\n\\n$$\\nab = 1 \\\\Rightarrow b = 1/a\\n$$\\n\\n由上式来看除法，乘除法是一个逆运算。当 $a = 0$ 时，我们找不到一个 $b$ 使第一个乘法式成立，0 自然也就不能作为除法的除数了。\\n\\nMapping\\n\\n数学的本质是映射，以加法为例，实际上是将数集 $V$ 映射到 $V$，也就是 $V \\\\times V \\\\rightarrow V$：\\n\\n$$\\n(\\\\alpha, \\\\beta) \\\\rightarrow \\\\gamma:=(\\\\alpha, \\\\beta)\\n$$\\n\\n仅仅是一个映射并不足够定...","tags":[{"slug":"matrix-theory","raw":"Matrix Theory"}],"categories":[{"slug":"math","raw":"Math","children":[{"slug":"math/algebra","raw":"Algebra","children":[]}]}],"createdAt":"2021-09-07T00:00:00.000Z"},"/posts/2021/10/31/games101.html":{"url":"/posts/2021/10/31/games101.html","title":"GAMES101","excerpt":"Links\\n\\nRasterization（光栅化）\\nGeometry（几何）\\nRay Tracing（光线追踪）\\nMaterial（材质）\\nLight Transport（相机、光场、颜色）\\nAnimation/Simulation（动画与仿真）\\nAssignment（作业）\\n\\nWhy we learning CG?\\n\\nWhat is Computer Graphics?\\n  Simulation\\n  Graphical User Interface\\n  Typography\\n  ...\\nWhy study Computer Graphics?\\n\\n  Fundamental Intellectual Challenges\\n  Technical Challenges\\nTrade off between real time and offline\\n\\nWhat different between Computer Graphics and Computer Vision?\\n\\nflowchart LR\\n  A([Model])\\n  B([Image])\\n  A--\\"Computer Grap...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-10-31T00:00:00.000Z"},"/posts/2021/11/13/games101-rasterization.html":{"url":"/posts/2021/11/13/games101-rasterization.html","title":"GAMES101: Rasterization","excerpt":"Rasterization（光栅化）\\n\\n光栅化是通过将顶点数据组成的场景渲染得到一张图片的方法。\\n\\nRaster**: Raster == screen in German, so rasterize == drawing onto the screen\\nFov**：可视角度，可以分为 fovX 和 fovY，两者可以通过宽高比转换\\nScreen**: An array of pixels, and size of array is resolution\\nPixel**: short for \\"picture element\\"\\n\\nTransformation\\n\\n对于一个场景，我们需要对其做 MVP 变换：\\n\\nflowchart LR\\n  A(\\"MVP Transformation\\")\\n  A --- B(\\"Modeling（模型） Transfromation\\")\\n  A --- C(\\"Viewing（视图） Transfromation\\")\\n  A --- D(\\"Projection（投影） Transformation\\")\\n  D --- E(\\"Orthographic（正交） T...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-11-13T00:00:00.000Z"},"/posts/2021/11/18/games101-geometry.html":{"url":"/posts/2021/11/18/games101-geometry.html","title":"GAMES101: Geometry","excerpt":"Curves and Meshes（几何）\\r\\n\\r\\n现实生活中的几何往往非常复杂，我们必须思考两个问题：\\r\\n\\r\\n如何存储\\r\\n如何渲染\\r\\nCurve\\r\\n\\r\\n关于一个几何形，我们可以通过显式或隐式的方法描述它。选择描述方法并不绝对，取决于实际。\\r\\n隐式描述\\r\\n\\r\\n隐式描述的方法通常是一组约束 $f(p) = 0$，这种方法容易判断一个点是否在面上，不易判断面上有哪些点。\\r\\n\\r\\nAlgebraic Surfaces（代数曲面，通常是一个隐函数）\\r\\nConstructive Solid Geometry (CSG)\\r\\n\\r\\n  Combine implicit geometry via Boolean operations\\r\\n\\r\\nSigned Distance Function（SDF，符号距离函数）\\r\\n\\r\\nLevel Set Methods (水平集)\\r\\n\\r\\n  水平集和 SDF 思想一样，不过它用一个矩阵存储一系列点上的函数值，通过这个点集我们就可以拟合任何一条 $f(x)=y$ 的曲线\\r\\n\\r\\nFractals（分形）\\r\\nSigned Distance Function\\r\\n\\r\\nCSG 通过 B...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-11-18T00:00:00.000Z"},"/posts/2021/11/30/games101-ray-tracing.html":{"url":"/posts/2021/11/30/games101-ray-tracing.html","title":"GAMES101: Ray Tracing","excerpt":"Ray Tracing（光线追踪）\\n\\n光栅化将物体分开着色，利用各种 Trade Off 的方案，最终将场景渲染成一张图片。光栅化（Ray Tracing）非常快速，但渲染结果并不是非常理想，它有一些一直无法很好解决的问题，例如：\\n\\nSoft shadows（软阴影）\\nGlossy reflection（有一定放射，但不是全光滑的材质）\\nIndirect illumination（间接光照，光线经过多次反射到达）\\n\\n而光线追踪则模拟真实物理场景，带给我们超高的渲染质量，不过它也不是用来完全取代光栅化的，譬如它最大的缺点就是慢，通常情况下都是用于离线渲染，不过现在也有 Real-Time Ray Tracing。\\n\\n通常现在的光线追踪都需要基于几个假设：\\n\\n光沿直线传播（though this is wrong)\\n两条光线不会互相干扰，即使它们交叉（though this is still wrong）\\n光路具有可逆性\\n\\n同时，我们为了计算方便，通常还假设：\\n\\n眼睛和光源都为点\\n\\nWhitted-Style Ray Tracing\\n\\nWhitted-Style 光线追踪是一种递归（Rec...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-11-30T00:00:00.000Z"},"/posts/2021/12/14/games101-material.html":{"url":"/posts/2021/12/14/games101-material.html","title":"GAMES101: Material","excerpt":"Materials（材质）\\n\\n分层\\n散射\\n次表面散射\\n\\nBasic\\n\\nDiffuse Material\\n\\nDiffuse Material\\n\\n对于一个向半球均匀漫反射的材质，我们假设物体不发光也不吸收光，入射光为常量，\\n\\n$$\\n\\\\begin{aligned}\\nL_0(\\\\omega_0)\\n&= \\\\int_{H^2}f_r L_i(\\\\omega_i) \\\\cos\\\\theta_i \\\\rm{d} \\\\omega_i\\n&&\\\\cdots \\\\text{The Rendering Equation} \\\\\\\\\\n&= f_r L_i \\\\int_{H^2} \\\\cos\\\\theta_i \\\\rm{d}\\\\omega_i\\n&&\\\\cdots \\\\text{假设入射光为常量} \\\\\\\\\\n&= \\\\pi f_r L_i\\n\\\\end{aligned}\\n$$\\n\\n又由假设有入射光等于出射光，我们定义反射率（albedo）为 $\\\\rho$，则不吸收光线的漫反射的 BRDF 可以定义为：\\n\\n$$\\nf_r = \\\\frac{\\\\rho}{\\\\pi} = c\\n$$\\n\\nGlossy Material\\n\\nGlossy Material\\n\\n在抛光金属的表面，反射没...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-12-14T00:00:00.000Z"},"/posts/2021/12/16/games101-light-transport.html":{"url":"/posts/2021/12/16/games101-light-transport.html","title":"GAMES101: Light Transport","excerpt":"Light Transport\\n\\nCameras\\n\\n现在用的相机都是小孔/透镜 + 传感器结构，因为传感器只能收集 Irradiance 信息，如果我们不对光线加以限制，那么得到的图像几乎是一种噪声图像，因此我们通过小孔成像原理限制光的入射方向。\\n\\n下图展示了无小孔的噪声成像（左）和小孔成像（右）。\\n\\nphotograph, Mars Cao, 2018\\n\\nFiled of View (FoV)\\n\\n视场（FOV）指的是能够看到的角度，通常可以分为水平 FOV 和垂直 FOV，垂直 FOV 与传感器大小与透镜组有关：\\n\\n$$\\n\\\\rm{FOV} = 2 \\\\arctan\\\\left(\\\\frac{h}{2f} \\\\right)\\n$$\\n\\n其中，$h$ 指的是传感器高度，$f$ 指的是焦距。为了统一，人们通常使用 35mm-format （36\\\\*24mm）大小的传感器来计算 FOV。\\n\\nExposure\\n\\n曝光（Exposure），曝光由曝光时间和曝光度决定：\\n\\n$$\\nExposure = Time \\\\times Irradiance\\n$$\\n\\n这些概念在相机中都有相同的结构，曝光时间可以由快门（Sh...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-12-16T00:00:00.000Z"},"/posts/2021/12/18/games101-animation-simulation.html":{"url":"/posts/2021/12/18/games101-animation-simulation.html","title":"GAMES101: Animation and Simulation","excerpt":"Animation and Simulation（动画/仿真）\\n\\n所谓动画就是一组连续的画面，当达到足够帧数后，由于人眼暂留现象就可以看见动画。不同显示设备对帧数也有不同的要求，如电影 24Hz、显示器 30Hz、VR/AR 90Hz。\\n\\n下文中，我们使用 $x$ 表示距离，$\\\\dot x$ 表示速度 $v$，$\\\\ddot x$ 表示加速度 $a$。\\n\\nKinematics\\n\\n地球上的动物大多都依赖于关节来带动四肢的旋转等动作，因此提到动画与仿真，离不开的就是研究关节是如何运动的。运动学（Kinematics）研究的就是这样的一件事情，特别的，在图形学中，我们还把它分为正运动学和逆运动学两块。\\n\\n正运动学（Forward Kinematics）关心的是我们如何通过关节的运动求解每个点的位置，例如一个人大臂抬起 30 度，小臂抬起 45 度后，求解他的手心位置。正运动学通常会使用三种不同的关节，分别为 Pin（钉住的关节，只能在一个平面内旋转）、Ball（球状的关节，可以绕着球旋转）和 Prismatic Joint（就像一个液压管！允许一定的伸缩）。\\n\\n逆运动学（Inverse Kin...","tags":[{"slug":"cg","raw":"CG"},{"slug":"games","raw":"GAMES"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/computer-graphics","raw":"Computer Graphics","children":[]}]}],"createdAt":"2021-12-18T00:00:00.000Z"},"/posts/2022/03/28/concurrency-tools-in-go.html":{"url":"/posts/2022/03/28/concurrency-tools-in-go.html","title":"Go 语言并发工具","excerpt":"使用通信来共享内存，而不是通过共享内存来通信\\n\\nGo 提供了 CSP 编程能力，但同时 sync 包也实现了 mutex，多数情况下，你应该选择 CSP.\\n\\nflowchart TD\\n   A(\\"这是一个对性能要求很高的临界区吗？\\")\\n   B(\\"你想要转让数据所有权吗？\\")\\n   C(\\"你是否试图保护某个结构的内部状态？\\")\\n   D(\\"你是否试图协调多个逻辑片段\\")\\n   E(\\"使用Mutex\\")\\n   F(\\"使用Channel\\")\\n   A --是--> E\\n   A --否--> B\\n   B --是--> F\\n   B --否--> C\\n   C --是--> E\\n   C --否--> D\\n   D --是--> F\\n   D --否--> E\\n\\nCoffman 条件被同时满足时，系统可能会死锁：\\n\\n相互排斥：并发进程拥有资源的独占权\\n等待条件：并发进程拥有资源并等待其他资源\\n没有抢占：资源不能被其他进程抢占\\n循环等待：P1->P2->P3->P1\\n\\nSync 包\\n\\n使用锁时候，尽量限制它的范围，隐藏调用细节，另外记得使用 defer 释放锁：\\n\\ntype Counter ...","tags":[{"slug":"go","raw":"Go"},{"slug":"concurrency","raw":"Concurrency"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/language","raw":"Language","children":[{"slug":"computer-science/language/go","raw":"Go","children":[]}]}]}],"createdAt":"2022-03-28T00:00:00.000Z"},"/posts/2022/04/02/pipeline-in-go.html":{"url":"/posts/2022/04/02/pipeline-in-go.html","title":"Pipeline in Go","excerpt":"代码节选自《Go 语言并发之道》，但升级为泛型版本（Go 1.18）\\n\\nPipeline\\n\\n流水线（Pipeline）在计算机科学中指的是一组将数据输入、执行操作、输出的 Stage 组合。使用流水线可以有效的拆分长函数逻辑，加快程序运行，并且拥有惰性求值、组合等特性。这是一个流水线的例子：\\n\\n// generate an int stream from integers\\nfunc generator(done <-chan any, integers ...int) <-chan int {\\n    intStream := make(chan int)\\n    go func() {\\n        defer close(intStream)\\n        for _, i := range integers {\\n            select {\\n            case <-done:\\n                return\\n            case intStream <- i:\\n            }\\n        }\\n    }()\\n...","tags":[{"slug":"go","raw":"Go"},{"slug":"concurrency","raw":"Concurrency"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/language","raw":"Language","children":[{"slug":"computer-science/language/go","raw":"Go","children":[]}]}]}],"createdAt":"2022-04-02T00:00:00.000Z"},"/posts/2022/04/04/cancel-goroutine.html":{"url":"/posts/2022/04/04/cancel-goroutine.html","title":"如何取消 goroutine","excerpt":"goroutine 有几种方式被终止：\\n\\n当它完成了他的工作\\n因为不可恢复的错误，它不能继续工作\\n当它被告知需要终止工作\\n\\n前两种是隐藏在算法中的，最后的是一种推荐的通信模式，pipeline 中使用这一模式来控制 stage。\\n\\nDone Channel\\n\\n考虑一个简单的 goroutine 泄漏：\\n\\ndoWork := func(strings <-chan string) <-chan any {\\n    completed := make(chan any)\\n    go func() {\\n        defer close(completed)\\n        for s := range strings {\\n            fmt.Println(s)\\n        }\\n    }\\n    return completed\\n}\\n\\ndoWork(nil) // strings is nil\\n\\n这一 Case 中，由于 strings是 nil，doWork 无法正常完成导致泄漏。更严重的是，如果我们试图 join 这两个 goroutine，会导致程序死锁。一个...","tags":[{"slug":"go","raw":"Go"},{"slug":"concurrency","raw":"Concurrency"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/language","raw":"Language","children":[{"slug":"computer-science/language/go","raw":"Go","children":[]}]}]}],"createdAt":"2022-04-04T00:00:00.000Z"},"/posts/2022/04/29/architectures-of-ddd.html":{"url":"/posts/2022/04/29/architectures-of-ddd.html","title":"领域驱动设计中的架构","excerpt":"领域驱动设计（Domain-Driven Design, DDD）是一种对代码语言、结构和组织方式的设计方法。DDD 一大好处就是它并不需要使用特定的架构，DDD 中核心逻辑被划分为不同的领域，每个领域都被包裹在限界上下文中，对于我们可以对不同领域使用多种多样的架构风格。对架构风格和模式的选择受到功能需求的限制，或者说在没有功能需求的情况下，我们是无法对软件质量做出评价的，也无法选择合适的架构。\\n建筑应该反映时代特征和地理特征，同时追求永恒。\\n—— Frank Gehry\\n\\n分层架构\\n\\n分层架构几乎是所有架构的始祖，被广泛应用在各种规模的软件中。分层架构的重要原则是每层只能与其下方的层发生耦合，如果只允许相邻的两层间发生耦合，被称为严格分层架构，而如果允许任意上层与任意下层发生耦合，则称为松散分层架构。一个典型的 DDD 系统所采用的松散分层架构如下图所示。\\n\\nLayered Architecture\\n\\n分层架构中领域层包含了系统中大部分业务逻辑，其他层都是为了将技术细节与领域层分离，使使业务逻辑的建模更加纯粹。应用层是很薄的一层，包裹领域层向外提供无状态的应用服务。用户接口层对外提供...","tags":[{"slug":"architecture","raw":"Architecture"},{"slug":"software-engineering","raw":"Software Engineering"}],"categories":[{"slug":"computer-science","raw":"Computer Science","children":[{"slug":"computer-science/software-engineering","raw":"Software Engineering","children":[]}]}],"createdAt":"2022-04-29T00:00:00.000Z"},"/posts/2023/08/14/cns2023-s46.html":{"url":"/posts/2023/08/14/cns2023-s46.html","title":"CNS 2023 - S46 Computing Neuro-Big-Data","excerpt":"7月30日上午，2023年中国神经科学学会年会专题研讨会 “Computing Neuro-Big-Data” 在珠海国际会展中心501C会议室成功举办。本次研讨会由东南大学彭汉川教授和广东省智能科学与技术研究院王宜敏研究员共同主持，邀请北京大学陈良怡教授、鹏城实验室周晖晖研究员、华中科技大学李安安教授、东南大学刘裕峰博士和广东省智能科学与技术研究院王宜敏研究员五位讲者，分享脑科学领域海量数据的产生和处理相关的前沿研究，带来了精彩纷呈的学术报告。...","tags":[{"slug":"news","raw":"News"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-08-14T00:00:00.000Z"},"/posts/2023/11/08/nervous-system.html":{"url":"/posts/2023/11/08/nervous-system.html","title":"神经系统组成","excerpt":"神经科学课程第一讲，讲者：李云庆教授（空军军医大学），主持人：朱筱娟教授（东北师范大学）。\\n\\n神经组织分为神经细胞和神经胶质细胞，神经的基本活动由反射组成。神经系统可以分为中枢神经系统和周围神经系统。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-11-08T00:00:00.000Z"},"/posts/2023/11/09/neuron.html":{"url":"/posts/2023/11/09/neuron.html","title":"神经系统的细胞组成","excerpt":"神经科学课程第一讲，讲者：鲍岚研究员（中科院分子细胞科学卓越创新中心），主持人：朱筱娟教授（东北师范大学）。\\n\\n神经组织主要分为神经细胞和神经胶质细胞，还包含免疫细胞、血管细胞等。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-11-09T00:00:00.000Z"},"/posts/2023/11/13/neuron-activity-principle.html":{"url":"/posts/2023/11/13/neuron-activity-principle.html","title":"神经元活动的基本原理","excerpt":"神经科学第二讲，讲者：石云研究员（广东省智能科学与技术研究院），主持人：朱筱娟教授（东北师范大学）。\\n\\n神经元膜表面具有多种多样的离子通道，在细胞膜两侧电化学梯度的驱动下，离子通道以超高速率高选择性地转运离子，建立细胞膜静息电位，并产生电信号。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-11-13T00:00:00.000Z"},"/posts/2023/12/10/neuron-electrical-activity.html":{"url":"/posts/2023/12/10/neuron-electrical-activity.html","title":"神经元的被动膜特性及动作电位的发生与传播","excerpt":"神经科学第二讲，讲者：舒友生（复旦大学），主持人：朱筱娟教授（东北师范大学）。\\n\\n神经元种类繁多、电活动模式多样。神经元和神经环路的电活动是实现脑功能的重要前提。神经元的电活动由细胞的被动和主动膜特性所决定的。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-12-10T00:00:00.000Z"},"/posts/2023/12/11/neurotransmitters-receptors.html":{"url":"/posts/2023/12/11/neurotransmitters-receptors.html","title":"神经递质及受体","excerpt":"神经科学第三讲，讲者：陆巍（复旦大学），主持人：朱筱娟教授（东北师范大学）。\\n\\n信号在神经元间传递主要依赖于神经递质，神经递质在突触前通过囊泡形式释放，并在突触后与受体结合，从而传播信号。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-12-11T00:00:00.000Z"},"/posts/2023/12/21/neurotransmitters-receptors-2.html":{"url":"/posts/2023/12/21/neurotransmitters-receptors-2.html","title":"神经递质及受体（二）","excerpt":"神经科学第三讲，讲者：高永静（南通大学），主持人：朱筱娟教授（东北师范大学）。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2023-12-21T00:00:00.000Z"},"/posts/2024/02/11/development-of-nerve-system.html":{"url":"/posts/2024/02/11/development-of-nerve-system.html","title":"神经系统的发生与分化","excerpt":"神经科学第四讲，讲者：赵春杰（东南大学），主持人：朱筱娟教授（东北师范大学）。\\n\\n神经系统的发育中，有两个基本问题：胚胎发育过程中，神经组织是如何衍化而来的？神经组织是如何进一步发育为脑和脊髓及其不同功能区域的？...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2024-02-11T00:00:00.000Z"},"/posts/2024/02/14/neurogenesis-1.html":{"url":"/posts/2024/02/14/neurogenesis-1.html","title":"神经元的生成","excerpt":"神经科学第五讲，讲者：禹永春（复旦大学），主持人：朱筱娟教授（东北师范大学）。\\n\\n大脑皮层 ~2500$cm^2$ 的面积下，约有 160 亿个神经元，形成了高度有序化的结构（ 六层结构、皮质功能柱、皮层区域化），其中约有 80% 兴奋性神经元、20% 中间神经元以及多种类的胶质细胞，神经元/胶质细胞是如何精确发育形成神经环路来执行我们的感知、运动、语言、情感、认知等脑功能仍是一个需要进一步探索的问题。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2024-02-14T00:00:00.000Z"},"/posts/2024/02/17/neurogenesis-2.html":{"url":"/posts/2024/02/17/neurogenesis-2.html","title":"神经元的发育","excerpt":"神经科学第五讲，讲者：禹永春（复旦大学），主持人：朱筱娟教授（东北师范大学）。\\n\\n在脑的发育过程中大量神经元的产生，它们不仅会定位到正确的位置，同时会形成不同功能、类型的神经元，让我们拥有了无与伦比的大脑结构。它不仅在早期时候时候产生了神经元，也指导我们在发育过程中形成了精巧的神经环路。尽管我们对它们的形成有一定的了解，但是仍然十分有限，有待进一步探索。...","tags":[{"slug":"course","raw":"Course"},{"slug":"neuron-science-2023","raw":"Neuron Science 2023"}],"categories":[{"slug":"neuron-science","raw":"Neuron Science","children":[]}],"createdAt":"2024-02-17T00:00:00.000Z"}}}`);export{n as d};
