import{g as e,h as i,o as l,j as t}from"./chunks/framework.BOQ8FqoK.js";const k=JSON.parse('{"title":"OAuth 2","description":"","frontmatter":{"title":"OAuth 2","date":"2019-03-16T10:37:11.000Z","categories":["Computer Science"],"tags":["Authorization","OAuth2"]},"headers":[{"level":1,"title":"OAuth 2","slug":"oauth-2","link":"#oauth-2","children":[{"level":2,"title":"名词定义","slug":"名词定义","link":"#名词定义","children":[]},{"level":2,"title":"Authorization Code Mode","slug":"authorization-code-mode","link":"#authorization-code-mode","children":[{"level":3,"title":"1. 用户访问客户端 (Client)","slug":"_1-用户访问客户端-client","link":"#_1-用户访问客户端-client","children":[]},{"level":3,"title":"2. 客户端将用户导向至认证服务器(Authorization Server)","slug":"_2-客户端将用户导向至认证服务器-authorization-server","link":"#_2-客户端将用户导向至认证服务器-authorization-server","children":[]},{"level":3,"title":"3. 用户授权","slug":"_3-用户授权","link":"#_3-用户授权","children":[]},{"level":3,"title":"4. 认证服务器将用户重定向回客户端","slug":"_4-认证服务器将用户重定向回客户端","link":"#_4-认证服务器将用户重定向回客户端","children":[]},{"level":3,"title":"5. 申请令牌","slug":"_5-申请令牌","link":"#_5-申请令牌","children":[]},{"level":3,"title":"6. 认证服务器发放 Token","slug":"_6-认证服务器发放-token","link":"#_6-认证服务器发放-token","children":[]},{"level":3,"title":"7. 访问资源(Resource)","slug":"_7-访问资源-resource","link":"#_7-访问资源-resource","children":[]},{"level":3,"title":"8. 刷新令牌","slug":"_8-刷新令牌","link":"#_8-刷新令牌","children":[]}]},{"level":2,"title":"Implicit Mode","slug":"implicit-mode","link":"#implicit-mode","children":[{"level":3,"title":"1. 用户访问客户端(Client)","slug":"_1-用户访问客户端-client-1","link":"#_1-用户访问客户端-client-1","children":[]},{"level":3,"title":"2. 客户端将用户导向至认证服务器(Authorization Server)","slug":"_2-客户端将用户导向至认证服务器-authorization-server-1","link":"#_2-客户端将用户导向至认证服务器-authorization-server-1","children":[]},{"level":3,"title":"3. 用户授权","slug":"_3-用户授权-1","link":"#_3-用户授权-1","children":[]},{"level":3,"title":"4. 认证服务器重定向回客户端","slug":"_4-认证服务器重定向回客户端","link":"#_4-认证服务器重定向回客户端","children":[]},{"level":3,"title":"5. 浏览器访问资源服务器，获取 script 解析 token","slug":"_5-浏览器访问资源服务器-获取-script-解析-token","link":"#_5-浏览器访问资源服务器-获取-script-解析-token","children":[]},{"level":3,"title":"6. 将 token 发送给 client","slug":"_6-将-token-发送给-client","link":"#_6-将-token-发送给-client","children":[]}]},{"level":2,"title":"resource owner password credentials","slug":"resource-owner-password-credentials","link":"#resource-owner-password-credentials","children":[]},{"level":2,"title":"client credentials","slug":"client-credentials","link":"#client-credentials","children":[]}]}],"relativePath":"posts/2019/03/16/oauth2.md","filePath":"posts/2019/03/16/oauth2.md"}'),r={name:"posts/2019/03/16/oauth2.md"},a=t('<h1 id="oauth-2" tabindex="-1">OAuth 2 <a class="header-anchor" href="#oauth-2" aria-label="Permalink to &quot;OAuth 2&quot;">​</a></h1><p><a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noreferrer">RFC6749</a></p><h2 id="名词定义" tabindex="-1">名词定义 <a class="header-anchor" href="#名词定义" aria-label="Permalink to &quot;名词定义&quot;">​</a></h2><ul><li>Third-party application</li></ul><p>第三方应用程序，本文中又称&quot;客户端&quot;(client)</p><ul><li>HTTP service</li></ul><p>HTTP服务提供商，本文中简称&quot;服务提供商&quot;，即上一节例子中的Google。</p><ul><li>Resource Owner</li></ul><p>资源所有者，本文中又称&quot;用户&quot;（user）</p><ul><li>User Agent</li></ul><p>用户代理，本文中就是指浏览器。</p><ul><li>Authorization server</li></ul><p>认证服务器，即服务提供商专门用来处理认证的服务器</p><ul><li>Resource server</li></ul><p>资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p><h2 id="authorization-code-mode" tabindex="-1">Authorization Code Mode <a class="header-anchor" href="#authorization-code-mode" aria-label="Permalink to &quot;Authorization Code Mode&quot;">​</a></h2><h3 id="_1-用户访问客户端-client" tabindex="-1">1. 用户访问客户端 (Client) <a class="header-anchor" href="#_1-用户访问客户端-client" aria-label="Permalink to &quot;1. 用户访问客户端 (Client)&quot;">​</a></h3><h3 id="_2-客户端将用户导向至认证服务器-authorization-server" tabindex="-1">2. 客户端将用户导向至认证服务器(Authorization Server) <a class="header-anchor" href="#_2-客户端将用户导向至认证服务器-authorization-server" aria-label="Permalink to &quot;2. 客户端将用户导向至认证服务器(Authorization Server)&quot;">​</a></h3><p>信息通过 url 明文传输, 对用户可见</p><ul><li>response_type : code</li><li>client_id</li><li>redirect_uri</li><li>scope(可选)</li><li>state(可选) <ul><li>用于保持请求和响应状态</li><li>防止跨站请求伪造（CSRF）攻击</li><li>服务器会将其与 code 一起带回</li></ul></li></ul><h3 id="_3-用户授权" tabindex="-1">3. 用户授权 <a class="header-anchor" href="#_3-用户授权" aria-label="Permalink to &quot;3. 用户授权&quot;">​</a></h3><h4 id="用户拒绝授权" tabindex="-1">用户拒绝授权 <a class="header-anchor" href="#用户拒绝授权" aria-label="Permalink to &quot;用户拒绝授权&quot;">​</a></h4><p>自定义</p><h4 id="client-id-redirect-uri-错误" tabindex="-1">client_id / redirect_uri 错误 <a class="header-anchor" href="#client-id-redirect-uri-错误" aria-label="Permalink to &quot;client_id / redirect_uri 错误&quot;">​</a></h4><ul><li>不重定向</li><li>显示错误消息</li></ul><h4 id="client-id-redirect-uri-正确但其他参数错误" tabindex="-1">client_id, redirect_uri 正确但其他参数错误 <a class="header-anchor" href="#client-id-redirect-uri-正确但其他参数错误" aria-label="Permalink to &quot;client_id, redirect_uri 正确但其他参数错误&quot;">​</a></h4><ul><li>重定向</li><li>附带错误参数 <ul><li><p>error</p><ul><li><p>invalid_request</p><p>请求缺少参数，包含无效参数，多次包含参数，或者无效。</p></li><li><p>access_denied</p><p>用户或授权服务器拒绝该请求</p></li><li><p>unauthorized_client</p><p>不允许客户端使用此方法请求授权代码，例如，如果机密客户端尝试使用隐式授权类型。</p></li><li><p>unsupported_response_type</p><p>服务器不支持使用此方法获取授权代码，例如，如果授权服务器从未实现隐式授权类型。</p></li><li><p>invalid_scope</p><p>请求的范围无效或未知。</p></li><li><p>server_error</p><p>服务器可以使用此错误代码重定向，而不是向用户显示500内部服务器错误页面。</p></li><li><p>temporarily_unavailable</p><p>如果服务器正在进行维护，或者不可用，则可以返回此错误代码，而不是使用503 Service Unavailable状态代码进行响应。</p></li></ul></li><li><p>error_description</p></li><li><p>error_uri</p></li><li><p>state</p></li></ul></li></ul><h3 id="_4-认证服务器将用户重定向回客户端" tabindex="-1">4. 认证服务器将用户重定向回客户端 <a class="header-anchor" href="#_4-认证服务器将用户重定向回客户端" aria-label="Permalink to &quot;4. 认证服务器将用户重定向回客户端&quot;">​</a></h3><ul><li>Authorization Code</li></ul><p>特点: 一次性使用, 有效时间短, 只需要认证服务器读懂, url 传输</p><p>非常适用 JWS，可以直接使用 JWT</p><ul><li><p>标准规定为 10 分钟</p></li><li><p>大部分网站为 30 - 60 秒</p></li><li><p>state 原样带回</p></li></ul><h3 id="_5-申请令牌" tabindex="-1">5. 申请令牌 <a class="header-anchor" href="#_5-申请令牌" aria-label="Permalink to &quot;5. 申请令牌&quot;">​</a></h3><p>客户端通过 Authorization Code 和 Redirect URI 向认证服务器申请 token</p><p>该过程在后台进行, 对用户不可见, 用户拿不到 token</p><h3 id="_6-认证服务器发放-token" tabindex="-1">6. 认证服务器发放 Token <a class="header-anchor" href="#_6-认证服务器发放-token" aria-label="Permalink to &quot;6. 认证服务器发放 Token&quot;">​</a></h3><p><strong>access_token</strong></p><ul><li><strong>token_type</strong> bearer, mac</li></ul><p><a href="https://www.cnblogs.com/XiongMaoMengNan/p/6785155.html" target="_blank" rel="noreferrer">OAuth 2.0: Bearer Token Usage</a></p><ul><li><p><strong>expires_in</strong> 失效时间，秒</p></li><li><p><strong>refresh_token</strong></p></li><li><p><strong>scope (可选)</strong></p></li><li><p><strong>other</strong></p></li></ul><p>HTTP Header 中设置 Cache-Control: no-store 可以提高安全性</p><h3 id="_7-访问资源-resource" tabindex="-1">7. 访问资源(Resource) <a class="header-anchor" href="#_7-访问资源-resource" aria-label="Permalink to &quot;7. 访问资源(Resource)&quot;">​</a></h3><p>with access token</p><h3 id="_8-刷新令牌" tabindex="-1">8. 刷新令牌 <a class="header-anchor" href="#_8-刷新令牌" aria-label="Permalink to &quot;8. 刷新令牌&quot;">​</a></h3><p>with refresh token</p><h2 id="implicit-mode" tabindex="-1">Implicit Mode <a class="header-anchor" href="#implicit-mode" aria-label="Permalink to &quot;Implicit Mode&quot;">​</a></h2><p>主要用于无服务器端的应用</p><p>涉及的角色包括: 用户(Resource Owner), UA(User Agent), 授权服务器, 资源服务器。</p><h3 id="_1-用户访问客户端-client-1" tabindex="-1">1. 用户访问客户端(Client) <a class="header-anchor" href="#_1-用户访问客户端-client-1" aria-label="Permalink to &quot;1. 用户访问客户端(Client)&quot;">​</a></h3><h3 id="_2-客户端将用户导向至认证服务器-authorization-server-1" tabindex="-1">2. 客户端将用户导向至认证服务器(Authorization Server) <a class="header-anchor" href="#_2-客户端将用户导向至认证服务器-authorization-server-1" aria-label="Permalink to &quot;2. 客户端将用户导向至认证服务器(Authorization Server)&quot;">​</a></h3><ul><li>response_type: token</li><li>client_id</li><li>redirect_uri</li><li>scope(可选)</li><li>state(可选)</li></ul><h3 id="_3-用户授权-1" tabindex="-1">3. 用户授权 <a class="header-anchor" href="#_3-用户授权-1" aria-label="Permalink to &quot;3. 用户授权&quot;">​</a></h3><h3 id="_4-认证服务器重定向回客户端" tabindex="-1">4. 认证服务器重定向回客户端 <a class="header-anchor" href="#_4-认证服务器重定向回客户端" aria-label="Permalink to &quot;4. 认证服务器重定向回客户端&quot;">​</a></h3><p>URI 的 hash 部分包含令牌</p><h3 id="_5-浏览器访问资源服务器-获取-script-解析-token" tabindex="-1">5. 浏览器访问资源服务器，获取 script 解析 token <a class="header-anchor" href="#_5-浏览器访问资源服务器-获取-script-解析-token" aria-label="Permalink to &quot;5. 浏览器访问资源服务器，获取 script 解析 token&quot;">​</a></h3><p>这一步不带 token</p><h3 id="_6-将-token-发送给-client" tabindex="-1">6. 将 token 发送给 client <a class="header-anchor" href="#_6-将-token-发送给-client" aria-label="Permalink to &quot;6. 将 token 发送给 client&quot;">​</a></h3><p>通常只有 access token, 不发放 refresh token</p><h2 id="resource-owner-password-credentials" tabindex="-1">resource owner password credentials <a class="header-anchor" href="#resource-owner-password-credentials" aria-label="Permalink to &quot;resource owner password credentials&quot;">​</a></h2><ol><li>用户将 username, password 交给 client</li><li>client 申请令牌</li><li>发放 token</li></ol><h2 id="client-credentials" tabindex="-1">client credentials <a class="header-anchor" href="#client-credentials" aria-label="Permalink to &quot;client credentials&quot;">​</a></h2><ol><li>客户端申请 token</li></ol><ul><li><p>granttype : clientcredentials</p></li><li><p>scope（可选）</p></li></ul><ol start="2"><li>发放 token</li></ol>',64),o=[a];function n(s,c,h,u,d,p){return l(),i("div",null,o)}const m=e(r,[["render",n]]);export{k as __pageData,m as default};
